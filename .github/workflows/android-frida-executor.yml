name: Android Security Testing - Complete Toolkit

on:
  workflow_dispatch:
    inputs:
      session_duration:
        description: 'Session duration in minutes (max 60)'
        required: true
        default: '30'
        type: choice
        options:
          - '15'
          - '30'
          - '45'
          - '60'
      android_api:
        description: 'Android API level'
        required: true
        default: '30'
        type: choice
        options:
          - '28'
          - '29'
          - '30'
          - '31'
          - '33'
      server_port:
        description: 'Remote executor server port'
        required: true
        default: '8000'
      enable_advanced_tools:
        description: 'Install advanced deobfuscation tools (adds ~3min)'
        required: true
        default: 'true'
        type: boolean

env:
  ANDROID_AVD_HOME: /home/runner/.android/avd
  ANDROID_SDK_ROOT: /usr/local/lib/android/sdk
  ANDROID_HOME: /usr/local/lib/android/sdk
  JAVA_HOME: /usr/lib/jvm/temurin-17-jdk-amd64
  ADB_DEVICE: localhost:5555

jobs:
  android-security-toolkit:
    runs-on: ubuntu-latest
    timeout-minutes: 65

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Enable KVM acceleration
        run: |
          echo 'KERNEL=="kvm", GROUP="kvm", MODE="0666", OPTIONS+="static_node=kvm"' | sudo tee /etc/udev/rules.d/99-kvm4all.rules
          sudo udevadm control --reload-rules
          sudo udevadm trigger --name-match=kvm
          echo "âœ… KVM enabled:"
          ls -la /dev/kvm

      - name: Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Core System Dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq \
            wget \
            curl \
            unzip \
            zip \
            git \
            jq \
            build-essential \
            cmake \
            pkg-config \
            libssl-dev \
            libffi-dev \
            libxml2-dev \
            libxslt1-dev \
            zlib1g-dev \
            libjpeg-dev \
            libpng-dev \
            android-tools-adb \
            android-tools-fastboot \
            aapt \
            apksigner \
            zipalign \
            openjdk-17-jdk \
            graphviz \
            libc6-i386 \
            lib32stdc++6 \
            lib32z1 \
            xz-utils
          echo "âœ… Core system dependencies installed"

      - name: Install Android SDK Build Tools
        run: |
          yes | sdkmanager --install "build-tools;34.0.0" 2>/dev/null || true
          yes | sdkmanager --install "build-tools;33.0.2" 2>/dev/null || true
          yes | sdkmanager --install "build-tools;30.0.3" 2>/dev/null || true
          
          echo "$ANDROID_HOME/build-tools/34.0.0" >> $GITHUB_PATH
          echo "$ANDROID_HOME/build-tools/33.0.2" >> $GITHUB_PATH
          echo "$ANDROID_HOME/build-tools/30.0.3" >> $GITHUB_PATH
          
          echo "âœ… Android SDK Build Tools installed:"
          ls -la $ANDROID_HOME/build-tools/ || echo "Build tools directory listing failed"

      - name: Install Python Security Tools
        run: |
          pip install --upgrade pip setuptools wheel
          pip install \
            fastapi \
            uvicorn[standard] \
            pyngrok \
            httpx \
            aiofiles \
            psutil \
            python-multipart \
            pydantic \
            frida-tools \
            frida \
            objection \
            lief \
            androguard \
            apkid \
            quark-engine \
            cryptography \
            pycryptodome \
            capstone \
            keystone-engine \
            unicorn \
            r2pipe \
            yara-python
          echo "âœ… Python security tools installed"
          
          echo "Tool versions:"
          frida --version || echo "frida version check failed"
          objection version 2>/dev/null || echo "objection installed"

      - name: Install APKTool
        run: |
          APKTOOL_VERSION="2.9.3"
          sudo wget -q "https://github.com/iBotPeaches/Apktool/releases/download/v${APKTOOL_VERSION}/apktool_${APKTOOL_VERSION}.jar" \
            -O /usr/local/bin/apktool.jar || { echo "APKTool jar download failed"; exit 1; }
          sudo wget -q "https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/linux/apktool" \
            -O /usr/local/bin/apktool || { echo "APKTool script download failed"; exit 1; }
          sudo chmod +x /usr/local/bin/apktool
          
          apktool --version && echo "âœ… APKTool $APKTOOL_VERSION installed"

      - name: Install JADX Decompiler
        run: |
          JADX_VERSION="1.5.0"
          wget -q "https://github.com/skylot/jadx/releases/download/v${JADX_VERSION}/jadx-${JADX_VERSION}.zip" \
            -O /tmp/jadx.zip || { echo "JADX download failed"; exit 1; }
          sudo unzip -q /tmp/jadx.zip -d /opt/jadx
          sudo ln -sf /opt/jadx/bin/jadx /usr/local/bin/jadx
          sudo ln -sf /opt/jadx/bin/jadx-gui /usr/local/bin/jadx-gui
          rm /tmp/jadx.zip
          
          jadx --version && echo "âœ… JADX $JADX_VERSION installed"

      - name: Install Dex2Jar
        continue-on-error: true
        run: |
          DEX2JAR_VERSION="2.4"
          wget -q "https://github.com/pxb1988/dex2jar/releases/download/v${DEX2JAR_VERSION}/dex-tools-v${DEX2JAR_VERSION}.zip" \
            -O /tmp/dex2jar.zip
          if [ -f /tmp/dex2jar.zip ] && [ -s /tmp/dex2jar.zip ]; then
            sudo unzip -q /tmp/dex2jar.zip -d /opt/
            sudo mv /opt/dex-tools-v${DEX2JAR_VERSION} /opt/dex2jar 2>/dev/null || sudo mv /opt/dex-tools-* /opt/dex2jar 2>/dev/null || true
            sudo chmod +x /opt/dex2jar/*.sh 2>/dev/null || true
            sudo ln -sf /opt/dex2jar/d2j-dex2jar.sh /usr/local/bin/d2j-dex2jar 2>/dev/null || true
            rm /tmp/dex2jar.zip
            echo "âœ… Dex2Jar installed"
          else
            echo "âš ï¸ Dex2Jar download failed, skipping"
          fi

      - name: Install Smali/Baksmali
        continue-on-error: true
        run: |
          # Using version 3.0.5 (latest verified version on GitHub)
          SMALI_VERSION="3.0.5"
          
          echo "Downloading smali ${SMALI_VERSION}..."
          sudo wget -q "https://github.com/google/smali/releases/download/v${SMALI_VERSION}/smali-${SMALI_VERSION}.jar" \
            -O /usr/local/bin/smali.jar || \
          sudo wget -q "https://bitbucket.org/JesusFreke/smali/downloads/smali-2.5.2.jar" \
            -O /usr/local/bin/smali.jar || \
          { echo "âš ï¸ smali download failed"; }
          
          echo "Downloading baksmali ${SMALI_VERSION}..."
          sudo wget -q "https://github.com/google/smali/releases/download/v${SMALI_VERSION}/baksmali-${SMALI_VERSION}.jar" \
            -O /usr/local/bin/baksmali.jar || \
          sudo wget -q "https://bitbucket.org/JesusFreke/smali/downloads/baksmali-2.5.2.jar" \
            -O /usr/local/bin/baksmali.jar || \
          { echo "âš ï¸ baksmali download failed"; }
          
          # Create wrapper scripts only if jars exist
          if [ -f /usr/local/bin/smali.jar ]; then
            echo '#!/bin/bash' | sudo tee /usr/local/bin/smali > /dev/null
            echo 'java -jar /usr/local/bin/smali.jar "$@"' | sudo tee -a /usr/local/bin/smali > /dev/null
            sudo chmod +x /usr/local/bin/smali
            echo "âœ… Smali installed"
          fi
          
          if [ -f /usr/local/bin/baksmali.jar ]; then
            echo '#!/bin/bash' | sudo tee /usr/local/bin/baksmali > /dev/null
            echo 'java -jar /usr/local/bin/baksmali.jar "$@"' | sudo tee -a /usr/local/bin/baksmali > /dev/null
            sudo chmod +x /usr/local/bin/baksmali
            echo "âœ… Baksmali installed"
          fi

      - name: Install Radare2
        continue-on-error: true
        run: |
          sudo apt-get install -y -qq radare2 || { echo "âš ï¸ radare2 apt install failed"; }
          r2 -v 2>/dev/null && echo "âœ… Radare2 installed" || echo "âš ï¸ Radare2 not available"

      - name: Install CFR Java Decompiler
        continue-on-error: true
        run: |
          CFR_VERSION="0.152"
          sudo wget -q "https://github.com/leibnitz27/cfr/releases/download/${CFR_VERSION}/cfr-${CFR_VERSION}.jar" \
            -O /usr/local/bin/cfr.jar || { echo "âš ï¸ CFR download failed"; exit 0; }
          
          if [ -f /usr/local/bin/cfr.jar ] && [ -s /usr/local/bin/cfr.jar ]; then
            echo '#!/bin/bash' | sudo tee /usr/local/bin/cfr > /dev/null
            echo 'java -jar /usr/local/bin/cfr.jar "$@"' | sudo tee -a /usr/local/bin/cfr > /dev/null
            sudo chmod +x /usr/local/bin/cfr
            echo "âœ… CFR $CFR_VERSION installed"
          fi

      - name: Install Procyon Decompiler
        continue-on-error: true
        run: |
          PROCYON_VERSION="0.6.0"
          sudo wget -q "https://github.com/mstrobel/procyon/releases/download/v${PROCYON_VERSION}/procyon-decompiler-${PROCYON_VERSION}.jar" \
            -O /usr/local/bin/procyon.jar || { echo "âš ï¸ Procyon download failed"; exit 0; }
          
          if [ -f /usr/local/bin/procyon.jar ] && [ -s /usr/local/bin/procyon.jar ]; then
            echo '#!/bin/bash' | sudo tee /usr/local/bin/procyon > /dev/null
            echo 'java -jar /usr/local/bin/procyon.jar "$@"' | sudo tee -a /usr/local/bin/procyon > /dev/null
            sudo chmod +x /usr/local/bin/procyon
            echo "âœ… Procyon $PROCYON_VERSION installed"
          fi

      - name: Install Enjarify
        continue-on-error: true
        run: |
          git clone --depth 1 https://github.com/Storyyeller/enjarify.git /tmp/enjarify 2>/dev/null || { echo "âš ï¸ Enjarify clone failed"; exit 0; }
          if [ -d "/tmp/enjarify" ]; then
            sudo mv /tmp/enjarify /opt/enjarify
            sudo ln -sf /opt/enjarify/enjarify.sh /usr/local/bin/enjarify
            echo "âœ… Enjarify installed"
          fi

      - name: Install Advanced Tools
        if: ${{ inputs.enable_advanced_tools == 'true' }}
        continue-on-error: true
        run: |
          echo "ðŸ“¦ Installing advanced deobfuscation tools..."
          
          # JD-CLI - Java Decompiler CLI
          JD_VERSION="1.2.1"
          wget -q "https://github.com/intoolswetrust/jd-cli/releases/download/jd-cli-${JD_VERSION}/jd-cli-${JD_VERSION}-dist.zip" \
            -O /tmp/jd-cli.zip 2>/dev/null || true
          if [ -f "/tmp/jd-cli.zip" ] && [ -s "/tmp/jd-cli.zip" ]; then
            sudo unzip -q /tmp/jd-cli.zip -d /opt/jd-cli 2>/dev/null || true
            if [ -f "/opt/jd-cli/jd-cli" ]; then
              sudo chmod +x /opt/jd-cli/jd-cli
              sudo ln -sf /opt/jd-cli/jd-cli /usr/local/bin/jd-cli
              echo "âœ… JD-CLI installed"
            fi
            rm -f /tmp/jd-cli.zip
          else
            echo "âš ï¸ JD-CLI download failed"
          fi
          
          echo "âœ… Advanced tools installation complete"

      - name: Create Frida Scripts Library
        run: |
          mkdir -p /tmp/frida-scripts
          
          # Universal SSL Pinning Bypass
          cat > /tmp/frida-scripts/ssl_bypass_universal.js << 'SSLSCRIPT'
          Java.perform(function() {
              console.log("[*] Universal SSL Bypass Loading...");
              
              // TrustManager Bypass
              try {
                  var TrustManager = Java.registerClass({
                      name: 'com.bypass.TrustManager',
                      implements: [Java.use('javax.net.ssl.X509TrustManager')],
                      methods: {
                          checkClientTrusted: function(chain, authType) {},
                          checkServerTrusted: function(chain, authType) {},
                          getAcceptedIssuers: function() { return []; }
                      }
                  });
                  var SSLContext = Java.use('javax.net.ssl.SSLContext');
                  SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;', '[Ljavax.net.ssl.TrustManager;', 'java.security.SecureRandom')
                      .implementation = function(km, tm, sr) {
                          console.log("[+] SSLContext.init bypassed");
                          this.init(km, [TrustManager.$new()], sr);
                      };
              } catch(e) { console.log("[-] TrustManager: " + e); }
              
              // OkHttp3 CertificatePinner
              try {
                  var CertPinner = Java.use('okhttp3.CertificatePinner');
                  CertPinner.check.overload('java.lang.String', 'java.util.List').implementation = function(h, p) {
                      console.log("[+] OkHttp3 pin bypassed: " + h);
                  };
              } catch(e) {}
              
              // OkHttp3 Builder
              try {
                  var Builder = Java.use('okhttp3.OkHttpClient$Builder');
                  Builder.certificatePinner.implementation = function(p) {
                      console.log("[+] OkHttp3 Builder.certificatePinner bypassed");
                      return this;
                  };
              } catch(e) {}
              
              // WebView SSL
              try {
                  var WebViewClient = Java.use('android.webkit.WebViewClient');
                  WebViewClient.onReceivedSslError.implementation = function(view, handler, error) {
                      console.log("[+] WebView SSL error bypassed");
                      handler.proceed();
                  };
              } catch(e) {}
              
              console.log("[*] Universal SSL Bypass Active!");
          });
          SSLSCRIPT
          
          # Root Detection Bypass
          cat > /tmp/frida-scripts/root_bypass_universal.js << 'ROOTSCRIPT'
          Java.perform(function() {
              console.log("[*] Root Detection Bypass Loading...");
              
              var RootFiles = [
                  "/system/app/Superuser.apk", "/system/xbin/su", "/system/bin/su",
                  "/sbin/su", "/data/local/xbin/su", "/data/local/bin/su",
                  "/system/sd/xbin/su", "/system/bin/failsafe/su",
                  "/data/local/su", "/su/bin/su", "/su/bin", "/magisk"
              ];
              
              try {
                  var File = Java.use('java.io.File');
                  File.exists.implementation = function() {
                      var path = this.getAbsolutePath();
                      for (var i = 0; i < RootFiles.length; i++) {
                          if (path === RootFiles[i] || path.indexOf("magisk") !== -1 || 
                              path.indexOf("supersu") !== -1 || path.indexOf("busybox") !== -1) {
                              console.log("[+] File.exists blocked: " + path);
                              return false;
                          }
                      }
                      return this.exists();
                  };
              } catch(e) {}
              
              // RootBeer
              try {
                  var RootBeer = Java.use('com.scottyab.rootbeer.RootBeer');
                  RootBeer.isRooted.implementation = function() {
                      console.log("[+] RootBeer.isRooted bypassed");
                      return false;
                  };
              } catch(e) {}
              
              // Block System.exit
              try {
                  var System = Java.use('java.lang.System');
                  System.exit.implementation = function(code) {
                      console.log("[+] System.exit(" + code + ") blocked!");
                  };
              } catch(e) {}
              
              console.log("[*] Root Detection Bypass Active!");
          });
          ROOTSCRIPT
          
          # Anti-Debug Bypass
          cat > /tmp/frida-scripts/anti_debug_bypass.js << 'DEBUGSCRIPT'
          Java.perform(function() {
              console.log("[*] Anti-Debug Bypass Loading...");
              
              try {
                  var Debug = Java.use('android.os.Debug');
                  Debug.isDebuggerConnected.implementation = function() {
                      console.log("[+] Debug.isDebuggerConnected bypassed");
                      return false;
                  };
              } catch(e) {}
              
              try {
                  var BufferedReader = Java.use('java.io.BufferedReader');
                  BufferedReader.readLine.implementation = function() {
                      var line = this.readLine();
                      if (line && line.indexOf("TracerPid") !== -1) {
                          return "TracerPid:\t0";
                      }
                      return line;
                  };
              } catch(e) {}
              
              console.log("[*] Anti-Debug Bypass Active!");
          });
          DEBUGSCRIPT
          
          # Network Monitor
          cat > /tmp/frida-scripts/network_monitor.js << 'NETSCRIPT'
          Java.perform(function() {
              console.log("[*] Network Monitor Loading...");
              
              try {
                  var URL = Java.use('java.net.URL');
                  URL.openConnection.overload().implementation = function() {
                      console.log("[URL] " + this.toString());
                      return this.openConnection();
                  };
              } catch(e) {}
              
              try {
                  var Request = Java.use('okhttp3.Request');
                  Request.url.implementation = function() {
                      var url = this.url();
                      console.log("[OkHttp] " + url.toString());
                      return url;
                  };
              } catch(e) {}
              
              console.log("[*] Network Monitor Active!");
          });
          NETSCRIPT
          
          # Crypto Monitor
          cat > /tmp/frida-scripts/crypto_monitor.js << 'CRYPTOSCRIPT'
          Java.perform(function() {
              console.log("[*] Crypto Monitor Loading...");
              
              function toHex(bytes) {
                  if (!bytes) return "null";
                  var hex = [];
                  for (var i = 0; i < Math.min(bytes.length, 32); i++) {
                      hex.push(("0" + (bytes[i] & 0xFF).toString(16)).slice(-2));
                  }
                  return hex.join("") + (bytes.length > 32 ? "..." : "");
              }
              
              try {
                  var Cipher = Java.use('javax.crypto.Cipher');
                  Cipher.getInstance.overload('java.lang.String').implementation = function(t) {
                      console.log("[Cipher] " + t);
                      return this.getInstance(t);
                  };
              } catch(e) {}
              
              try {
                  var SecretKeySpec = Java.use('javax.crypto.spec.SecretKeySpec');
                  SecretKeySpec.$init.overload('[B', 'java.lang.String').implementation = function(key, alg) {
                      console.log("[KEY] " + alg + ": " + toHex(key));
                      return this.$init(key, alg);
                  };
              } catch(e) {}
              
              console.log("[*] Crypto Monitor Active!");
          });
          CRYPTOSCRIPT
          
          # DexGuard String Logger
          cat > /tmp/frida-scripts/dexguard_strings.js << 'DEXSCRIPT'
          Java.perform(function() {
              console.log("[*] DexGuard String Logger Loading...");
              
              try {
                  var StringClass = Java.use('java.lang.String');
                  StringClass.$init.overload('[B').implementation = function(bytes) {
                      var result = StringClass.$new(bytes);
                      if (bytes.length > 3 && bytes.length < 500) {
                          console.log("[STRING] " + result);
                      }
                      return result;
                  };
              } catch(e) {}
              
              try {
                  var StringBuilder = Java.use('java.lang.StringBuilder');
                  StringBuilder.toString.implementation = function() {
                      var result = this.toString();
                      if (result.length > 5 && result.length < 500) {
                          if (result.indexOf("http") !== -1 || result.indexOf("key") !== -1 ||
                              result.indexOf("token") !== -1 || result.indexOf("api") !== -1) {
                              console.log("[BUILDER] " + result);
                          }
                      }
                      return result;
                  };
              } catch(e) {}
              
              console.log("[*] DexGuard String Logger Active!");
          });
          DEXSCRIPT
          
          echo "âœ… Frida scripts library created"
          ls -la /tmp/frida-scripts/

      - name: Install Android System Image
        run: |
          yes | sdkmanager --install "system-images;android-${{ inputs.android_api }};google_apis;x86_64" 2>/dev/null || true
          yes | sdkmanager --install "platforms;android-${{ inputs.android_api }}" 2>/dev/null || true
          yes | sdkmanager --install "platform-tools" 2>/dev/null || true
          echo "âœ… Android system image installed"

      - name: Create Android Virtual Device
        run: |
          mkdir -p $HOME/.android/avd
          echo "no" | avdmanager create avd \
            --force \
            --name "security_avd" \
            --package "system-images;android-${{ inputs.android_api }};google_apis;x86_64" \
            --device "pixel_4"
          
          echo "âœ… AVD created"
          avdmanager list avd

      - name: Setup ngrok
        run: |
          curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | \
            sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
          echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | \
            sudo tee /etc/apt/sources.list.d/ngrok.list
          sudo apt-get update -qq && sudo apt-get install -y -qq ngrok
          ngrok config add-authtoken ${{ secrets.NGROK_AUTH_TOKEN }}
          echo "âœ… ngrok configured"

      - name: Start Android Emulator
        run: |
          echo "ðŸš€ Starting emulator..."
          
          $ANDROID_HOME/emulator/emulator -avd security_avd \
            -no-window \
            -no-audio \
            -no-boot-anim \
            -gpu swiftshader_indirect \
            -no-snapshot \
            -port 5554 \
            -memory 2048 &
          
          EMULATOR_PID=$!
          echo "EMULATOR_PID=$EMULATOR_PID" >> $GITHUB_ENV
          
          echo "â³ Waiting for device..."
          adb wait-for-device
          
          echo "â³ Waiting for boot..."
          timeout=180
          elapsed=0
          while [ "$(adb shell getprop sys.boot_completed 2>/dev/null)" != "1" ]; do
            if [ $elapsed -ge $timeout ]; then
              echo "âŒ Boot timeout"
              exit 1
            fi
            sleep 5
            elapsed=$((elapsed + 5))
            echo "  ${elapsed}s..."
          done
          
          echo "âœ… Emulator booted in ${elapsed}s"
          adb devices -l
          
          adb tcpip 5555
          sleep 2
          adb connect localhost:5555
          adb disconnect emulator-5554 2>/dev/null || true
          
          echo "ðŸ“± Final devices:"
          adb devices -l

      - name: Verify Emulator and Tools
        run: |
          echo "ðŸ“± Device Info:"
          adb -s localhost:5555 shell getprop ro.product.model
          adb -s localhost:5555 shell getprop ro.build.version.release
          
          echo ""
          echo "ðŸ”§ Installed Tools:"
          echo "  APKTool: $(apktool --version 2>/dev/null || echo 'N/A')"
          echo "  JADX: $(jadx --version 2>/dev/null || echo 'N/A')"
          echo "  Frida: $(frida --version 2>/dev/null || echo 'N/A')"
          echo "  Objection: $(objection version 2>/dev/null || echo 'N/A')"
          echo "  R2: $(r2 -v 2>/dev/null | head -1 || echo 'N/A')"

      - name: Create Working Directories
        run: |
          mkdir -p /tmp/apks
          mkdir -p /tmp/patched
          mkdir -p /tmp/decompiled
          mkdir -p /tmp/downloads
          mkdir -p /tmp/output
          mkdir -p /tmp/logs
          echo "âœ… Working directories created"

      - name: Start Remote Executor Server
        run: |
          cat > /tmp/android_security_executor.py << 'SERVEREOF'
          #!/usr/bin/env python3
          """
          Android Security Testing Remote Executor v3.0
          Complete toolkit for APK analysis including DexGuard support
          """
          
          import os
          import sys
          import json
          import time
          import asyncio
          import subprocess
          import traceback
          import shutil
          import hashlib
          from io import StringIO
          from typing import Optional, Dict, Any, List
          from contextlib import redirect_stdout, redirect_stderr
          from pathlib import Path
          
          from fastapi import FastAPI, HTTPException, UploadFile, File, Form
          from fastapi.middleware.cors import CORSMiddleware
          from fastapi.responses import FileResponse, JSONResponse
          from pydantic import BaseModel
          import frida
          
          app = FastAPI(
              title="Android Security Testing Executor",
              description="Complete toolkit for APK security analysis",
              version="3.0.0"
          )
          
          app.add_middleware(
              CORSMiddleware,
              allow_origins=["*"],
              allow_credentials=True,
              allow_methods=["*"],
              allow_headers=["*"],
          )
          
          ADB_DEVICE = "localhost:5555"
          WORK_DIR = Path("/tmp")
          APK_DIR = WORK_DIR / "apks"
          PATCHED_DIR = WORK_DIR / "patched"
          DECOMPILED_DIR = WORK_DIR / "decompiled"
          SCRIPTS_DIR = WORK_DIR / "frida-scripts"
          OUTPUT_DIR = WORK_DIR / "output"
          
          execution_namespace = {"__builtins__": __builtins__}
          frida_device = None
          frida_session = None
          frida_scripts = {}
          
          class CodeRequest(BaseModel):
              code: str
              timeout: Optional[int] = 300
          
          class BashRequest(BaseModel):
              command: str
              timeout: Optional[int] = 300
          
          class ADBRequest(BaseModel):
              command: str
              timeout: Optional[int] = 60
          
          class FridaScriptRequest(BaseModel):
              script: str
              process_name: Optional[str] = "Gadget"
              script_name: Optional[str] = "default"
          
          class APKPatchRequest(BaseModel):
              apk_path: str
              architecture: str = "x86_64"
          
          class DecompileRequest(BaseModel):
              apk_path: str
              tool: str = "jadx"
              output_dir: Optional[str] = None
          
          @app.get("/")
          def root():
              return {
                  "service": "Android Security Testing Executor",
                  "version": "3.0.0",
                  "status": "online",
                  "endpoints": {
                      "system": ["/health", "/disk", "/tools"],
                      "execution": ["/execute", "/bash", "/adb"],
                      "apk": ["/apk/info", "/apk/patch", "/apk/install", "/apk/decompile", "/apk/identify"],
                      "frida": ["/frida/connect", "/frida/script", "/frida/ssl-bypass", "/frida/root-bypass"],
                      "files": ["/upload", "/download", "/ls", "/read"]
                  }
              }
          
          @app.get("/health")
          def health():
              import psutil
              adb_result = subprocess.run(["adb", "devices"], capture_output=True, text=True)
              emulator_ok = "localhost:5555" in adb_result.stdout or "emulator" in adb_result.stdout
              
              return {
                  "status": "healthy",
                  "cpu_percent": psutil.cpu_percent(),
                  "memory_percent": psutil.virtual_memory().percent,
                  "disk_free_gb": round(psutil.disk_usage('/').free / (1024**3), 2),
                  "emulator_connected": emulator_ok,
                  "frida_version": frida.__version__,
                  "frida_session_active": frida_session is not None,
                  "adb_device": ADB_DEVICE
              }
          
          @app.get("/tools")
          def list_tools():
              tools = {}
              checks = [
                  ("apktool", "apktool --version"),
                  ("jadx", "jadx --version"),
                  ("frida", "frida --version"),
                  ("objection", "objection version"),
                  ("r2", "r2 -v"),
                  ("aapt2", "aapt2 version"),
                  ("apksigner", "apksigner --version"),
              ]
              
              for name, cmd in checks:
                  try:
                      result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=10)
                      output = (result.stdout + result.stderr).strip().split('\n')[0][:100]
                      tools[name] = {"installed": True, "version": output}
                  except:
                      tools[name] = {"installed": False, "version": None}
              
              return {"success": True, "tools": tools}
          
          @app.post("/execute")
          def execute_code(request: CodeRequest):
              stdout_capture = StringIO()
              stderr_capture = StringIO()
              result = None
              error = None
              
              try:
                  with redirect_stdout(stdout_capture), redirect_stderr(stderr_capture):
                      exec(request.code, execution_namespace)
              except Exception as e:
                  error = f"{type(e).__name__}: {str(e)}\n{traceback.format_exc()}"
              
              return {
                  "success": error is None,
                  "stdout": stdout_capture.getvalue(),
                  "stderr": stderr_capture.getvalue(),
                  "result": repr(result) if result is not None else None,
                  "error": error
              }
          
          @app.post("/bash")
          def execute_bash(request: BashRequest):
              try:
                  result = subprocess.run(
                      request.command, shell=True, capture_output=True, text=True,
                      timeout=request.timeout, env={**os.environ, "PATH": os.environ.get("PATH", "") + ":/usr/local/bin"}
                  )
                  return {
                      "success": result.returncode == 0,
                      "returncode": result.returncode,
                      "stdout": result.stdout,
                      "stderr": result.stderr
                  }
              except subprocess.TimeoutExpired:
                  return {"success": False, "error": f"Timeout after {request.timeout}s"}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/adb")
          def execute_adb(request: ADBRequest):
              try:
                  cmd = f"adb -s {ADB_DEVICE} {request.command}"
                  result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=request.timeout)
                  return {
                      "success": result.returncode == 0,
                      "command": cmd,
                      "stdout": result.stdout,
                      "stderr": result.stderr
                  }
              except subprocess.TimeoutExpired:
                  return {"success": False, "error": f"Timeout after {request.timeout}s"}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.get("/adb/devices")
          def adb_devices():
              result = subprocess.run(["adb", "devices", "-l"], capture_output=True, text=True)
              lines = result.stdout.strip().split('\n')[1:]
              devices = []
              for line in lines:
                  if line.strip():
                      parts = line.split()
                      if len(parts) >= 2:
                          devices.append({"id": parts[0], "state": parts[1], "info": ' '.join(parts[2:])})
              return {"success": True, "devices": devices}
          
          @app.get("/adb/packages")
          def adb_packages(filter: Optional[str] = None):
              cmd = f"adb -s {ADB_DEVICE} shell pm list packages"
              if filter:
                  cmd += f" | grep -i {filter}"
              result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
              packages = [p.replace("package:", "") for p in result.stdout.strip().split('\n') if p]
              return {"success": True, "packages": packages, "count": len(packages)}
          
          @app.get("/apk/info")
          def apk_info(apk_path: str):
              try:
                  aapt_paths = [
                      "/usr/local/lib/android/sdk/build-tools/34.0.0/aapt2",
                      "/usr/local/lib/android/sdk/build-tools/33.0.2/aapt2",
                      "aapt2", "aapt"
                  ]
                  
                  result = None
                  for aapt in aapt_paths:
                      try:
                          result = subprocess.run(f"{aapt} dump badging {apk_path}", shell=True, capture_output=True, text=True, timeout=30)
                          if result.returncode == 0:
                              break
                      except:
                          continue
                  
                  if not result or result.returncode != 0:
                      result = subprocess.run(f"aapt dump badging {apk_path}", shell=True, capture_output=True, text=True)
                  
                  info = {"raw": result.stdout[:5000]}
                  
                  for line in result.stdout.split('\n'):
                      if line.startswith("package:"):
                          parts = line.split("'")
                          info["package_name"] = parts[1] if len(parts) > 1 else None
                          info["version_code"] = parts[3] if len(parts) > 3 else None
                          info["version_name"] = parts[5] if len(parts) > 5 else None
                      elif line.startswith("application-label:"):
                          info["app_name"] = line.split("'")[1] if "'" in line else None
                      elif line.startswith("sdkVersion:"):
                          info["min_sdk"] = line.split("'")[1] if "'" in line else None
                      elif line.startswith("targetSdkVersion:"):
                          info["target_sdk"] = line.split("'")[1] if "'" in line else None
                  
                  with open(apk_path, 'rb') as f:
                      info["sha256"] = hashlib.sha256(f.read()).hexdigest()
                  info["size_mb"] = round(os.path.getsize(apk_path) / (1024*1024), 2)
                  
                  return {"success": True, "info": info}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.get("/apk/identify")
          def apk_identify(apk_path: str):
              try:
                  result = subprocess.run(
                      f"apkid -j {apk_path}",
                      shell=True, capture_output=True, text=True, timeout=120
                  )
                  
                  if result.returncode == 0:
                      try:
                          data = json.loads(result.stdout)
                          return {"success": True, "apkid": data}
                      except:
                          return {"success": True, "apkid_raw": result.stdout}
                  else:
                      return {"success": False, "error": result.stderr, "stdout": result.stdout}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/apk/patch")
          def patch_apk(request: APKPatchRequest):
              try:
                  apk_path = Path(request.apk_path)
                  if not apk_path.exists():
                      return {"success": False, "error": f"APK not found: {apk_path}"}
                  
                  env = os.environ.copy()
                  env["PATH"] = f"/usr/local/lib/android/sdk/build-tools/34.0.0:{env.get('PATH', '')}"
                  
                  cmd = f"objection patchapk -s {apk_path} -a {request.architecture}"
                  
                  result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=300, env=env)
                  
                  patched_name = apk_path.stem + ".objection.apk"
                  patched_path = apk_path.parent / patched_name
                  
                  if patched_path.exists() and patched_path.stat().st_size > 0:
                      check = subprocess.run(f"unzip -l {patched_path} | grep -i frida", shell=True, capture_output=True, text=True)
                      has_gadget = "frida" in check.stdout.lower()
                      
                      return {
                          "success": True,
                          "original_apk": str(apk_path),
                          "patched_apk": str(patched_path),
                          "size_mb": round(patched_path.stat().st_size / (1024*1024), 2),
                          "has_frida_gadget": has_gadget,
                          "stdout": result.stdout[-2000:] if result.stdout else "",
                          "stderr": result.stderr[-1000:] if result.stderr else ""
                      }
                  else:
                      return {
                          "success": False,
                          "error": "Patching failed - output file not created or empty",
                          "stdout": result.stdout,
                          "stderr": result.stderr
                      }
              except subprocess.TimeoutExpired:
                  return {"success": False, "error": "Patching timed out after 300s"}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/apk/install")
          def install_apk(apk_path: str):
              try:
                  result = subprocess.run(
                      f"adb -s {ADB_DEVICE} install -r -g {apk_path}",
                      shell=True, capture_output=True, text=True, timeout=120
                  )
                  success = "Success" in result.stdout or result.returncode == 0
                  return {"success": success, "apk_path": apk_path, "stdout": result.stdout, "stderr": result.stderr}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/apk/launch")
          def launch_app(package_name: str):
              try:
                  result = subprocess.run(
                      f"adb -s {ADB_DEVICE} shell monkey -p {package_name} -c android.intent.category.LAUNCHER 1",
                      shell=True, capture_output=True, text=True
                  )
                  return {"success": result.returncode == 0, "package": package_name, "stdout": result.stdout, "stderr": result.stderr}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/apk/decompile")
          def decompile_apk(request: DecompileRequest):
              try:
                  apk_path = Path(request.apk_path)
                  if not apk_path.exists():
                      return {"success": False, "error": "APK not found"}
                  
                  output = Path(request.output_dir) if request.output_dir else DECOMPILED_DIR / apk_path.stem
                  output.mkdir(parents=True, exist_ok=True)
                  
                  if request.tool == "jadx":
                      cmd = f"jadx -d {output} --deobf {apk_path}"
                  elif request.tool == "apktool":
                      cmd = f"apktool d -f -o {output} {apk_path}"
                  else:
                      return {"success": False, "error": f"Unknown tool: {request.tool}"}
                  
                  result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=300)
                  
                  return {
                      "success": result.returncode == 0,
                      "tool": request.tool,
                      "output_dir": str(output),
                      "stdout": result.stdout[-2000:],
                      "stderr": result.stderr[-1000:]
                  }
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/frida/connect")
          def frida_connect():
              global frida_device
              try:
                  subprocess.run(["adb", "-s", ADB_DEVICE, "forward", "tcp:27042", "tcp:27042"], check=True)
                  frida_device = frida.get_device_manager().add_remote_device("127.0.0.1:27042")
                  return {"success": True, "device": str(frida_device), "message": "Connected"}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.get("/frida/processes")
          def frida_processes():
              global frida_device
              if not frida_device:
                  return {"success": False, "error": "Not connected"}
              try:
                  procs = frida_device.enumerate_processes()
                  return {"success": True, "processes": [{"pid": p.pid, "name": p.name} for p in procs]}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/frida/attach")
          def frida_attach(process_name: str = "Gadget"):
              global frida_device, frida_session
              if not frida_device:
                  r = frida_connect()
                  if not r.get("success"):
                      return r
              try:
                  frida_session = frida_device.attach(process_name)
                  return {"success": True, "message": f"Attached to {process_name}"}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/frida/script")
          def frida_load_script(request: FridaScriptRequest):
              global frida_session, frida_scripts
              if not frida_session:
                  r = frida_attach(request.process_name)
                  if not r.get("success"):
                      return r
              
              messages = []
              def on_message(msg, data):
                  messages.append(msg)
              
              try:
                  script = frida_session.create_script(request.script)
                  script.on('message', on_message)
                  script.load()
                  frida_scripts[request.script_name] = script
                  time.sleep(0.5)
                  return {"success": True, "script_name": request.script_name, "messages": messages}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/frida/script-file")
          def frida_load_script_file(script_path: str, process_name: str = "Gadget"):
              try:
                  with open(script_path, 'r') as f:
                      script_content = f.read()
                  return frida_load_script(FridaScriptRequest(
                      script=script_content,
                      process_name=process_name,
                      script_name=Path(script_path).stem
                  ))
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/frida/ssl-bypass")
          def frida_ssl_bypass(process_name: str = "Gadget"):
              script_path = "/tmp/frida-scripts/ssl_bypass_universal.js"
              if os.path.exists(script_path):
                  return frida_load_script_file(script_path, process_name)
              return {"success": False, "error": "SSL bypass script not found"}
          
          @app.post("/frida/root-bypass")
          def frida_root_bypass(process_name: str = "Gadget"):
              script_path = "/tmp/frida-scripts/root_bypass_universal.js"
              if os.path.exists(script_path):
                  return frida_load_script_file(script_path, process_name)
              return {"success": False, "error": "Root bypass script not found"}
          
          @app.post("/frida/anti-debug-bypass")
          def frida_debug_bypass(process_name: str = "Gadget"):
              script_path = "/tmp/frida-scripts/anti_debug_bypass.js"
              if os.path.exists(script_path):
                  return frida_load_script_file(script_path, process_name)
              return {"success": False, "error": "Anti-debug bypass script not found"}
          
          @app.post("/frida/dexguard-strings")
          def frida_dexguard_strings(process_name: str = "Gadget"):
              script_path = "/tmp/frida-scripts/dexguard_strings.js"
              if os.path.exists(script_path):
                  return frida_load_script_file(script_path, process_name)
              return {"success": False, "error": "DexGuard strings script not found"}
          
          @app.get("/frida/scripts")
          def frida_list_scripts():
              return {"success": True, "scripts": list(frida_scripts.keys())}
          
          @app.get("/frida/scripts-available")
          def frida_available_scripts():
              scripts = []
              for f in Path("/tmp/frida-scripts").glob("*.js"):
                  scripts.append({"name": f.stem, "path": str(f)})
              return {"success": True, "scripts": scripts}
          
          @app.post("/upload")
          async def upload_file(file: UploadFile = File(...), destination: str = Form(default="/tmp/apks")):
              try:
                  dest = Path(destination)
                  dest.mkdir(parents=True, exist_ok=True)
                  filepath = dest / file.filename
                  
                  content = await file.read()
                  with open(filepath, "wb") as f:
                      f.write(content)
                  
                  return {"success": True, "filepath": str(filepath), "size_bytes": len(content)}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/download")
          def download_file(url: str, destination: str = "/tmp/downloads", filename: Optional[str] = None):
              try:
                  dest = Path(destination)
                  dest.mkdir(parents=True, exist_ok=True)
                  
                  fname = filename or url.split('/')[-1].split('?')[0]
                  filepath = dest / fname
                  
                  result = subprocess.run(f'curl -L -o "{filepath}" "{url}"', shell=True, capture_output=True, timeout=600)
                  
                  if filepath.exists() and filepath.stat().st_size > 0:
                      return {"success": True, "filepath": str(filepath), "size_mb": round(filepath.stat().st_size / (1024*1024), 2)}
                  return {"success": False, "error": "Download failed"}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.get("/ls")
          def list_dir(path: str = "/tmp"):
              try:
                  p = Path(path)
                  if not p.exists():
                      return {"success": False, "error": "Path not found"}
                  items = [{"name": i.name, "is_dir": i.is_dir(), "size": i.stat().st_size if i.is_file() else None} for i in p.iterdir()]
                  return {"success": True, "path": path, "items": items}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.get("/read")
          def read_file(path: str, max_size: int = 1048576):
              try:
                  p = Path(path)
                  if not p.exists():
                      return {"success": False, "error": "File not found"}
                  if p.stat().st_size > max_size:
                      return {"success": False, "error": f"File too large (>{max_size} bytes)"}
                  with open(p, 'r') as f:
                      return {"success": True, "path": path, "content": f.read()}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.get("/disk")
          def disk_usage():
              import shutil
              total, used, free = shutil.disk_usage("/")
              return {
                  "total_gb": round(total / (1024**3), 2),
                  "used_gb": round(used / (1024**3), 2),
                  "free_gb": round(free / (1024**3), 2),
                  "percent_used": round(used / total * 100, 1)
              }
          
          if __name__ == "__main__":
              import uvicorn
              uvicorn.run(app, host="0.0.0.0", port=8000)
          SERVEREOF
          
          echo "âœ… Remote executor server created"

      - name: Start ngrok and Server
        run: |
          PORT=${{ inputs.server_port }}
          
          python3 /tmp/android_security_executor.py &
          SERVER_PID=$!
          echo "SERVER_PID=$SERVER_PID" >> $GITHUB_ENV
          sleep 5
          
          curl -s http://localhost:$PORT/health || { echo "Server failed to start"; exit 1; }
          
          ngrok http $PORT --log=stdout > /tmp/ngrok.log 2>&1 &
          NGROK_PID=$!
          echo "NGROK_PID=$NGROK_PID" >> $GITHUB_ENV
          sleep 5
          
          NGROK_URL=$(curl -s http://localhost:4040/api/tunnels | jq -r '.tunnels[0].public_url')
          
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ðŸŽ¯ ANDROID SECURITY TOOLKIT READY!"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ðŸ“¡ PUBLIC URL: $NGROK_URL"
          echo ""
          echo "ðŸ”§ Available Tools:"
          echo "   â€¢ Decompilers: JADX, APKTool"
          echo "   â€¢ Analysis: APKiD, Androguard, Radare2"
          echo "   â€¢ Instrumentation: Frida, Objection"
          echo ""
          echo "ðŸ“š API Docs: $NGROK_URL/docs"
          echo "â° Session: ${{ inputs.session_duration }} minutes"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""

      - name: Keep Session Alive
        run: |
          duration=${{ inputs.session_duration }}
          elapsed=0
          interval=60
          
          while [ $elapsed -lt $((duration * 60)) ]; do
            sleep $interval
            elapsed=$((elapsed + interval))
            
            emu="âŒ"
            srv="âŒ"
            
            if adb -s localhost:5555 shell getprop sys.boot_completed 2>/dev/null | grep -q "1"; then
              emu="âœ…"
            fi
            
            if curl -s http://localhost:${{ inputs.server_port }}/health | grep -q "healthy"; then
              srv="âœ…"
            fi
            
            echo "[$(date +%H:%M:%S)] Emulator: $emu | Server: $srv | ${elapsed}s / $((duration * 60))s"
          done
          
          echo "â° Session ended"

      - name: Cleanup
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up..."
          kill $NGROK_PID 2>/dev/null || true
          kill $EMULATOR_PID 2>/dev/null || true
          kill $SERVER_PID 2>/dev/null || true
          adb -s localhost:5555 emu kill 2>/dev/null || true
          adb kill-server 2>/dev/null || true
          echo "âœ… Done"
