name: Android Security Testing - Complete Toolkit

on:
  workflow_dispatch:
    inputs:
      session_duration:
        description: 'Session duration in minutes (max 60)'
        required: true
        default: '30'
        type: choice
        options:
          - '15'
          - '30'
          - '45'
          - '60'
      android_api:
        description: 'Android API level'
        required: true
        default: '30'
        type: choice
        options:
          - '28'
          - '29'
          - '30'
          - '31'
          - '33'
      server_port:
        description: 'Remote executor server port'
        required: true
        default: '8000'
      enable_advanced_tools:
        description: 'Install advanced deobfuscation tools (adds ~3min)'
        required: true
        default: 'true'
        type: boolean

env:
  ANDROID_AVD_HOME: /home/runner/.android/avd
  ANDROID_SDK_ROOT: /usr/local/lib/android/sdk
  ANDROID_HOME: /usr/local/lib/android/sdk
  ANDROID_NDK_HOME: /usr/local/lib/android/sdk/ndk/25.2.9519653
  JAVA_HOME: /usr/lib/jvm/temurin-17-jdk-amd64
  GRADLE_HOME: /usr/share/gradle
  ADB_DEVICE: localhost:5555

jobs:
  android-security-toolkit:
    runs-on: ubuntu-latest
    timeout-minutes: 65

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Enable KVM acceleration
        run: |
          echo 'KERNEL=="kvm", GROUP="kvm", MODE="0666", OPTIONS+="static_node=kvm"' | sudo tee /etc/udev/rules.d/99-kvm4all.rules
          sudo udevadm control --reload-rules
          sudo udevadm trigger --name-match=kvm
          echo "âœ… KVM enabled:"
          ls -la /dev/kvm

      - name: Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Core System Dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq \
            wget \
            curl \
            unzip \
            zip \
            git \
            jq \
            build-essential \
            cmake \
            pkg-config \
            libssl-dev \
            libffi-dev \
            libxml2-dev \
            libxslt1-dev \
            zlib1g-dev \
            libjpeg-dev \
            libpng-dev \
            android-tools-adb \
            android-tools-fastboot \
            aapt \
            apksigner \
            zipalign \
            openjdk-17-jdk \
            graphviz \
            libc6-i386 \
            lib32stdc++6 \
            lib32z1
          echo "âœ… Core system dependencies installed"

      - name: Install Android SDK Build Tools
        run: |
          # Install multiple build-tools versions for compatibility
          yes | sdkmanager --install "build-tools;34.0.0" 2>/dev/null || true
          yes | sdkmanager --install "build-tools;33.0.2" 2>/dev/null || true
          yes | sdkmanager --install "build-tools;30.0.3" 2>/dev/null || true
          
          # Add to PATH - prefer newer versions
          echo "$ANDROID_HOME/build-tools/34.0.0" >> $GITHUB_PATH
          echo "$ANDROID_HOME/build-tools/33.0.2" >> $GITHUB_PATH
          echo "$ANDROID_HOME/build-tools/30.0.3" >> $GITHUB_PATH
          
          # Verify tools
          echo "âœ… Android SDK Build Tools installed:"
          ls -la $ANDROID_HOME/build-tools/
          
          # Test aapt2
          $ANDROID_HOME/build-tools/34.0.0/aapt2 version || echo "aapt2 34 not available"
          $ANDROID_HOME/build-tools/33.0.2/aapt2 version || echo "aapt2 33 not available"

      - name: Install Python Security Tools
        run: |
          pip install --upgrade pip setuptools wheel
          pip install \
            fastapi \
            uvicorn[standard] \
            pyngrok \
            httpx \
            aiofiles \
            psutil \
            python-multipart \
            pydantic \
            frida-tools \
            frida \
            objection \
            lief \
            androguard \
            apkid \
            quark-engine \
            cryptography \
            pycryptodome \
            capstone \
            keystone-engine \
            unicorn \
            r2pipe \
            yara-python
          echo "âœ… Python security tools installed"
          
          # Verify installations
          echo "Tool versions:"
          frida --version
          objection version || echo "objection version check skipped"
          apkid --version || echo "apkid installed"

      - name: Install APKTool
        run: |
          # Install latest apktool
          APKTOOL_VERSION="2.9.3"
          sudo wget -q "https://github.com/iBotPeaches/Apktool/releases/download/v${APKTOOL_VERSION}/apktool_${APKTOOL_VERSION}.jar" \
            -O /usr/local/bin/apktool.jar
          sudo wget -q "https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/linux/apktool" \
            -O /usr/local/bin/apktool
          sudo chmod +x /usr/local/bin/apktool
          
          # Verify
          apktool --version
          echo "âœ… APKTool $APKTOOL_VERSION installed"

      - name: Install JADX Decompiler
        run: |
          JADX_VERSION="1.5.0"
          wget -q "https://github.com/skylot/jadx/releases/download/v${JADX_VERSION}/jadx-${JADX_VERSION}.zip" \
            -O /tmp/jadx.zip
          sudo unzip -q /tmp/jadx.zip -d /opt/jadx
          sudo ln -sf /opt/jadx/bin/jadx /usr/local/bin/jadx
          sudo ln -sf /opt/jadx/bin/jadx-gui /usr/local/bin/jadx-gui
          rm /tmp/jadx.zip
          
          # Verify
          jadx --version
          echo "âœ… JADX $JADX_VERSION installed"

      - name: Install Dex2Jar
        run: |
          DEX2JAR_VERSION="2.4"
          wget -q "https://github.com/pxb1988/dex2jar/releases/download/v${DEX2JAR_VERSION}/dex-tools-v${DEX2JAR_VERSION}.zip" \
            -O /tmp/dex2jar.zip
          sudo unzip -q /tmp/dex2jar.zip -d /opt/
          sudo mv /opt/dex-tools-v${DEX2JAR_VERSION} /opt/dex2jar
          sudo chmod +x /opt/dex2jar/*.sh
          sudo ln -sf /opt/dex2jar/d2j-dex2jar.sh /usr/local/bin/d2j-dex2jar
          sudo ln -sf /opt/dex2jar/d2j-jar2dex.sh /usr/local/bin/d2j-jar2dex
          rm /tmp/dex2jar.zip
          echo "âœ… Dex2Jar $DEX2JAR_VERSION installed"

      - name: Install Smali/Baksmali
        run: |
          SMALI_VERSION="2.5.2"
          sudo wget -q "https://github.com/JesusFreke/smali/releases/download/v${SMALI_VERSION}/smali-${SMALI_VERSION}.jar" \
            -O /usr/local/bin/smali.jar
          sudo wget -q "https://github.com/JesusFreke/smali/releases/download/v${SMALI_VERSION}/baksmali-${SMALI_VERSION}.jar" \
            -O /usr/local/bin/baksmali.jar
          
          # Create wrapper scripts
          echo '#!/bin/bash' | sudo tee /usr/local/bin/smali
          echo 'java -jar /usr/local/bin/smali.jar "$@"' | sudo tee -a /usr/local/bin/smali
          sudo chmod +x /usr/local/bin/smali
          
          echo '#!/bin/bash' | sudo tee /usr/local/bin/baksmali
          echo 'java -jar /usr/local/bin/baksmali.jar "$@"' | sudo tee -a /usr/local/bin/baksmali
          sudo chmod +x /usr/local/bin/baksmali
          
          echo "âœ… Smali/Baksmali $SMALI_VERSION installed"

      - name: Install Radare2
        run: |
          # Install radare2 from package (faster)
          sudo apt-get install -y -qq radare2
          
          # Verify
          r2 -v
          echo "âœ… Radare2 installed"

      - name: Install CFR Java Decompiler
        run: |
          CFR_VERSION="0.152"
          sudo wget -q "https://github.com/leibnitz27/cfr/releases/download/${CFR_VERSION}/cfr-${CFR_VERSION}.jar" \
            -O /usr/local/bin/cfr.jar
          
          echo '#!/bin/bash' | sudo tee /usr/local/bin/cfr
          echo 'java -jar /usr/local/bin/cfr.jar "$@"' | sudo tee -a /usr/local/bin/cfr
          sudo chmod +x /usr/local/bin/cfr
          echo "âœ… CFR $CFR_VERSION installed"

      - name: Install Procyon Decompiler
        run: |
          PROCYON_VERSION="0.6.0"
          sudo wget -q "https://github.com/mstrobel/procyon/releases/download/v${PROCYON_VERSION}/procyon-decompiler-${PROCYON_VERSION}.jar" \
            -O /usr/local/bin/procyon.jar
          
          echo '#!/bin/bash' | sudo tee /usr/local/bin/procyon
          echo 'java -jar /usr/local/bin/procyon.jar "$@"' | sudo tee -a /usr/local/bin/procyon
          sudo chmod +x /usr/local/bin/procyon
          echo "âœ… Procyon $PROCYON_VERSION installed"

      - name: Install Enjarify (Google's dex2jar alternative)
        run: |
          git clone --depth 1 https://github.com/Storyyeller/enjarify.git /tmp/enjarify
          sudo mv /tmp/enjarify /opt/enjarify
          sudo ln -sf /opt/enjarify/enjarify.sh /usr/local/bin/enjarify
          echo "âœ… Enjarify installed"

      - name: Install Advanced Tools (DexGuard/Obfuscation)
        if: ${{ inputs.enable_advanced_tools == 'true' }}
        run: |
          echo "ðŸ“¦ Installing advanced deobfuscation tools..."
          
          # Simplify - Android deobfuscator
          git clone --depth 1 https://github.com/CalebFenton/simplify.git /tmp/simplify || true
          if [ -d "/tmp/simplify" ]; then
            cd /tmp/simplify
            ./gradlew fatjar 2>/dev/null || echo "Simplify build skipped"
            if [ -f "simplify/build/libs/simplify.jar" ]; then
              sudo cp simplify/build/libs/simplify.jar /usr/local/bin/
              echo '#!/bin/bash' | sudo tee /usr/local/bin/simplify
              echo 'java -jar /usr/local/bin/simplify.jar "$@"' | sudo tee -a /usr/local/bin/simplify
              sudo chmod +x /usr/local/bin/simplify
              echo "âœ… Simplify installed"
            fi
          fi
          
          # JD-CLI - Java Decompiler CLI
          JD_VERSION="1.2.1"
          wget -q "https://github.com/intoolswetrust/jd-cli/releases/download/jd-cli-${JD_VERSION}/jd-cli-${JD_VERSION}-dist.zip" \
            -O /tmp/jd-cli.zip || true
          if [ -f "/tmp/jd-cli.zip" ]; then
            sudo unzip -q /tmp/jd-cli.zip -d /opt/jd-cli
            sudo chmod +x /opt/jd-cli/jd-cli
            sudo ln -sf /opt/jd-cli/jd-cli /usr/local/bin/jd-cli
            echo "âœ… JD-CLI installed"
          fi
          
          # ByteCodeViewer
          BCV_VERSION="2.12"
          wget -q "https://github.com/Konloch/bytecode-viewer/releases/download/v${BCV_VERSION}/Bytecode-Viewer-${BCV_VERSION}.jar" \
            -O /usr/local/bin/bytecode-viewer.jar 2>/dev/null || true
          if [ -f "/usr/local/bin/bytecode-viewer.jar" ]; then
            echo "âœ… ByteCode Viewer installed"
          fi
          
          echo "âœ… Advanced tools installation complete"

      - name: Create Frida Scripts Library
        run: |
          mkdir -p /tmp/frida-scripts
          
          # Universal SSL Pinning Bypass
          cat > /tmp/frida-scripts/ssl_bypass_universal.js << 'SSLEOF'
          /*
           * Universal SSL Pinning Bypass
           * Supports: OkHttp, Retrofit, HttpURLConnection, WebView,
           * TrustManager, TrustKit, Appcelerator, Flutter, Xamarin
           */
          Java.perform(function() {
              console.log("[*] Universal SSL Bypass Loading...");
              
              // TrustManager Bypass
              try {
                  var TrustManager = Java.registerClass({
                      name: 'com.bypass.TrustManager',
                      implements: [Java.use('javax.net.ssl.X509TrustManager')],
                      methods: {
                          checkClientTrusted: function(chain, authType) {},
                          checkServerTrusted: function(chain, authType) {},
                          getAcceptedIssuers: function() { return []; }
                      }
                  });
                  var SSLContext = Java.use('javax.net.ssl.SSLContext');
                  SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;', '[Ljavax.net.ssl.TrustManager;', 'java.security.SecureRandom')
                      .implementation = function(km, tm, sr) {
                          console.log("[+] SSLContext.init bypassed");
                          this.init(km, [TrustManager.$new()], sr);
                      };
              } catch(e) { console.log("[-] TrustManager: " + e); }
              
              // OkHttp3 CertificatePinner
              try {
                  var CertPinner = Java.use('okhttp3.CertificatePinner');
                  CertPinner.check.overload('java.lang.String', 'java.util.List').implementation = function(h, p) {
                      console.log("[+] OkHttp3 pin bypassed: " + h);
                  };
                  CertPinner.check.overload('java.lang.String', '[Ljava.security.cert.Certificate;').implementation = function(h, p) {
                      console.log("[+] OkHttp3 pin bypassed: " + h);
                  };
              } catch(e) {}
              
              // OkHttp3 Builder
              try {
                  var Builder = Java.use('okhttp3.OkHttpClient$Builder');
                  Builder.certificatePinner.implementation = function(p) {
                      console.log("[+] OkHttp3 Builder.certificatePinner bypassed");
                      return this;
                  };
              } catch(e) {}
              
              // TrustKit
              try {
                  var TrustKit = Java.use('com.datatheorem.android.trustkit.pinning.OkHostnameVerifier');
                  TrustKit.verify.overload('java.lang.String', 'javax.net.ssl.SSLSession').implementation = function(h, s) {
                      console.log("[+] TrustKit bypassed: " + h);
                      return true;
                  };
              } catch(e) {}
              
              // HostnameVerifier
              try {
                  var HV = Java.use('javax.net.ssl.HostnameVerifier');
                  var HVImpl = Java.registerClass({
                      name: 'com.bypass.HostnameVerifier',
                      implements: [HV],
                      methods: {
                          verify: function(h, s) { return true; }
                      }
                  });
              } catch(e) {}
              
              // WebView SSL
              try {
                  var WebViewClient = Java.use('android.webkit.WebViewClient');
                  WebViewClient.onReceivedSslError.implementation = function(view, handler, error) {
                      console.log("[+] WebView SSL error bypassed");
                      handler.proceed();
                  };
              } catch(e) {}
              
              // Network Security Config
              try {
                  var NSC = Java.use('android.security.net.config.NetworkSecurityConfig');
                  NSC.isCleartextTrafficPermitted.overload().implementation = function() { return true; };
                  NSC.isCleartextTrafficPermitted.overload('java.lang.String').implementation = function(h) { return true; };
              } catch(e) {}
              
              console.log("[*] Universal SSL Bypass Active!");
          });
          SSLEOF
          
          # Root Detection Bypass
          cat > /tmp/frida-scripts/root_bypass_universal.js << 'ROOTEOF'
          /*
           * Universal Root Detection Bypass
           * Supports: RootBeer, SafetyNet, common detection methods
           */
          Java.perform(function() {
              console.log("[*] Root Detection Bypass Loading...");
              
              // Common file checks
              var RootFiles = [
                  "/system/app/Superuser.apk", "/system/xbin/su", "/system/bin/su",
                  "/sbin/su", "/data/local/xbin/su", "/data/local/bin/su",
                  "/system/sd/xbin/su", "/system/bin/failsafe/su",
                  "/data/local/su", "/su/bin/su", "/su/bin", "/magisk"
              ];
              
              // File.exists bypass
              try {
                  var File = Java.use('java.io.File');
                  File.exists.implementation = function() {
                      var path = this.getAbsolutePath();
                      for (var i = 0; i < RootFiles.length; i++) {
                          if (path === RootFiles[i] || path.indexOf("magisk") !== -1 || 
                              path.indexOf("supersu") !== -1 || path.indexOf("busybox") !== -1) {
                              console.log("[+] File.exists blocked: " + path);
                              return false;
                          }
                      }
                      return this.exists();
                  };
              } catch(e) {}
              
              // RootBeer
              try {
                  var RootBeer = Java.use('com.scottyab.rootbeer.RootBeer');
                  RootBeer.isRooted.implementation = function() {
                      console.log("[+] RootBeer.isRooted bypassed");
                      return false;
                  };
                  RootBeer.isRootedWithoutBusyBoxCheck.implementation = function() { return false; };
                  RootBeer.detectRootManagementApps.implementation = function() { return false; };
                  RootBeer.detectPotentiallyDangerousApps.implementation = function() { return false; };
                  RootBeer.detectTestKeys.implementation = function() { return false; };
                  RootBeer.checkForBusyBoxBinary.implementation = function() { return false; };
                  RootBeer.checkForSuBinary.implementation = function() { return false; };
                  RootBeer.checkSuExists.implementation = function() { return false; };
                  RootBeer.checkForRWPaths.implementation = function() { return false; };
                  RootBeer.checkForDangerousProps.implementation = function() { return false; };
                  RootBeer.checkForRootNative.implementation = function() { return false; };
                  RootBeer.detectRootCloakingApps.implementation = function() { return false; };
                  RootBeer.isSelinuxFlagInEnabled.implementation = function() { return true; };
              } catch(e) {}
              
              // Runtime.exec bypass for su checks
              try {
                  var Runtime = Java.use('java.lang.Runtime');
                  var execOrig = Runtime.exec.overload('java.lang.String');
                  execOrig.implementation = function(cmd) {
                      if (cmd.indexOf("su") !== -1 || cmd.indexOf("which") !== -1) {
                          console.log("[+] Runtime.exec blocked: " + cmd);
                          throw new Error("Command not found");
                      }
                      return execOrig.call(this, cmd);
                  };
              } catch(e) {}
              
              // System.getProperty
              try {
                  var System = Java.use('java.lang.System');
                  System.getProperty.overload('java.lang.String').implementation = function(key) {
                      if (key === "ro.build.tags") {
                          return "release-keys";
                      }
                      return this.getProperty(key);
                  };
              } catch(e) {}
              
              // Block System.exit for anti-tamper
              try {
                  var SystemExit = Java.use('java.lang.System');
                  SystemExit.exit.implementation = function(code) {
                      console.log("[+] System.exit(" + code + ") blocked!");
                  };
              } catch(e) {}
              
              console.log("[*] Root Detection Bypass Active!");
          });
          ROOTEOF
          
          # Anti-Debug Bypass
          cat > /tmp/frida-scripts/anti_debug_bypass.js << 'DEBUGEOF'
          /*
           * Anti-Debugging Bypass
           * Bypasses: ptrace, Debug.isDebuggerConnected, timing checks
           */
          Java.perform(function() {
              console.log("[*] Anti-Debug Bypass Loading...");
              
              // Debug.isDebuggerConnected
              try {
                  var Debug = Java.use('android.os.Debug');
                  Debug.isDebuggerConnected.implementation = function() {
                      console.log("[+] Debug.isDebuggerConnected bypassed");
                      return false;
                  };
                  Debug.waitingForDebugger.implementation = function() { return false; };
              } catch(e) {}
              
              // ApplicationInfo flags
              try {
                  var ApplicationInfo = Java.use('android.content.pm.ApplicationInfo');
                  ApplicationInfo.flags.value = 0;
              } catch(e) {}
              
              // TracerPid check
              try {
                  var BufferedReader = Java.use('java.io.BufferedReader');
                  BufferedReader.readLine.implementation = function() {
                      var line = this.readLine();
                      if (line && line.indexOf("TracerPid") !== -1) {
                          return "TracerPid:\t0";
                      }
                      return line;
                  };
              } catch(e) {}
              
              console.log("[*] Anti-Debug Bypass Active!");
          });
          DEBUGEOF
          
          # DexGuard String Decryption Helper
          cat > /tmp/frida-scripts/dexguard_strings.js << 'DEXEOF'
          /*
           * DexGuard String Decryption Logger
           * Logs decrypted strings at runtime
           */
          Java.perform(function() {
              console.log("[*] DexGuard String Logger Loading...");
              
              // Hook String constructor to catch decrypted strings
              try {
                  var StringClass = Java.use('java.lang.String');
                  StringClass.$init.overload('[B').implementation = function(bytes) {
                      var result = StringClass.$new(bytes);
                      if (bytes.length > 3 && bytes.length < 500) {
                          console.log("[STRING] " + result);
                      }
                      return result;
                  };
                  StringClass.$init.overload('[B', 'java.lang.String').implementation = function(bytes, charset) {
                      var result = StringClass.$new(bytes, charset);
                      if (bytes.length > 3 && bytes.length < 500) {
                          console.log("[STRING] " + result);
                      }
                      return result;
                  };
              } catch(e) {}
              
              // Hook StringBuilder for concatenated strings
              try {
                  var StringBuilder = Java.use('java.lang.StringBuilder');
                  StringBuilder.toString.implementation = function() {
                      var result = this.toString();
                      if (result.length > 5 && result.length < 500) {
                          if (result.indexOf("http") !== -1 || result.indexOf("key") !== -1 ||
                              result.indexOf("token") !== -1 || result.indexOf("api") !== -1) {
                              console.log("[BUILDER] " + result);
                          }
                      }
                      return result;
                  };
              } catch(e) {}
              
              console.log("[*] DexGuard String Logger Active!");
          });
          DEXEOF
          
          # Network Traffic Monitor
          cat > /tmp/frida-scripts/network_monitor.js << 'NETEOF'
          /*
           * Comprehensive Network Traffic Monitor
           */
          Java.perform(function() {
              console.log("[*] Network Monitor Loading...");
              
              // URL connections
              try {
                  var URL = Java.use('java.net.URL');
                  URL.openConnection.overload().implementation = function() {
                      console.log("[URL] " + this.toString());
                      return this.openConnection();
                  };
              } catch(e) {}
              
              // OkHttp
              try {
                  var Request = Java.use('okhttp3.Request');
                  Request.url.implementation = function() {
                      var url = this.url();
                      console.log("[OkHttp] " + url.toString());
                      return url;
                  };
              } catch(e) {}
              
              // Retrofit
              try {
                  var ServiceMethod = Java.use('retrofit2.ServiceMethod');
                  ServiceMethod.invoke.implementation = function(args) {
                      console.log("[Retrofit] Service method invoked");
                      return this.invoke(args);
                  };
              } catch(e) {}
              
              console.log("[*] Network Monitor Active!");
          });
          NETEOF
          
          # Crypto Monitor
          cat > /tmp/frida-scripts/crypto_monitor.js << 'CRYPTOEOF'
          /*
           * Cryptographic Operations Monitor
           */
          Java.perform(function() {
              console.log("[*] Crypto Monitor Loading...");
              
              function toHex(bytes) {
                  if (!bytes) return "null";
                  var hex = [];
                  for (var i = 0; i < Math.min(bytes.length, 32); i++) {
                      hex.push(("0" + (bytes[i] & 0xFF).toString(16)).slice(-2));
                  }
                  return hex.join("") + (bytes.length > 32 ? "..." : "");
              }
              
              // Cipher
              try {
                  var Cipher = Java.use('javax.crypto.Cipher');
                  Cipher.getInstance.overload('java.lang.String').implementation = function(t) {
                      console.log("[Cipher] " + t);
                      return this.getInstance(t);
                  };
                  Cipher.doFinal.overload('[B').implementation = function(input) {
                      console.log("[Cipher.doFinal] IN: " + toHex(input));
                      var result = this.doFinal(input);
                      console.log("[Cipher.doFinal] OUT: " + toHex(result));
                      return result;
                  };
              } catch(e) {}
              
              // SecretKeySpec
              try {
                  var SecretKeySpec = Java.use('javax.crypto.spec.SecretKeySpec');
                  SecretKeySpec.$init.overload('[B', 'java.lang.String').implementation = function(key, alg) {
                      console.log("[KEY] " + alg + ": " + toHex(key));
                      return this.$init(key, alg);
                  };
              } catch(e) {}
              
              // MessageDigest
              try {
                  var MD = Java.use('java.security.MessageDigest');
                  MD.digest.overload('[B').implementation = function(input) {
                      var result = this.digest(input);
                      console.log("[Hash] " + this.getAlgorithm() + " -> " + toHex(result));
                      return result;
                  };
              } catch(e) {}
              
              console.log("[*] Crypto Monitor Active!");
          });
          CRYPTOEOF
          
          echo "âœ… Frida scripts library created"
          ls -la /tmp/frida-scripts/

      - name: Install Android System Image
        run: |
          yes | sdkmanager --install "system-images;android-${{ inputs.android_api }};google_apis;x86_64" 2>/dev/null || true
          yes | sdkmanager --install "platforms;android-${{ inputs.android_api }}" 2>/dev/null || true
          yes | sdkmanager --install "platform-tools" 2>/dev/null || true
          echo "âœ… Android system image installed"

      - name: Create Android Virtual Device
        run: |
          mkdir -p $HOME/.android/avd
          echo "no" | avdmanager create avd \
            --force \
            --name "security_avd" \
            --package "system-images;android-${{ inputs.android_api }};google_apis;x86_64" \
            --device "pixel_4"
          
          echo "âœ… AVD created"
          avdmanager list avd

      - name: Setup ngrok
        run: |
          curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | \
            sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
          echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | \
            sudo tee /etc/apt/sources.list.d/ngrok.list
          sudo apt-get update -qq && sudo apt-get install -y -qq ngrok
          ngrok config add-authtoken ${{ secrets.NGROK_AUTH_TOKEN }}
          echo "âœ… ngrok configured"

      - name: Start Android Emulator
        run: |
          echo "ðŸš€ Starting emulator..."
          
          $ANDROID_HOME/emulator/emulator -avd security_avd \
            -no-window \
            -no-audio \
            -no-boot-anim \
            -gpu swiftshader_indirect \
            -no-snapshot \
            -port 5554 \
            -memory 2048 &
          
          EMULATOR_PID=$!
          echo "EMULATOR_PID=$EMULATOR_PID" >> $GITHUB_ENV
          
          echo "â³ Waiting for device..."
          adb wait-for-device
          
          echo "â³ Waiting for boot..."
          timeout=180
          elapsed=0
          while [ "$(adb shell getprop sys.boot_completed 2>/dev/null)" != "1" ]; do
            if [ $elapsed -ge $timeout ]; then
              echo "âŒ Boot timeout"
              exit 1
            fi
            sleep 5
            elapsed=$((elapsed + 5))
            echo "  ${elapsed}s..."
          done
          
          echo "âœ… Emulator booted in ${elapsed}s"
          adb devices -l
          
          # Setup ADB TCP
          adb tcpip 5555
          sleep 2
          adb connect localhost:5555
          adb disconnect emulator-5554 2>/dev/null || true
          
          echo "ðŸ“± Final devices:"
          adb devices -l

      - name: Verify Emulator and Tools
        run: |
          echo "ðŸ“± Device Info:"
          adb -s localhost:5555 shell getprop ro.product.model
          adb -s localhost:5555 shell getprop ro.build.version.release
          
          echo ""
          echo "ðŸ”§ Installed Tools:"
          echo "  APKTool: $(apktool --version 2>/dev/null || echo 'N/A')"
          echo "  JADX: $(jadx --version 2>/dev/null || echo 'N/A')"
          echo "  Frida: $(frida --version 2>/dev/null || echo 'N/A')"
          echo "  Objection: $(objection version 2>/dev/null || echo 'N/A')"
          echo "  APKiD: $(apkid --version 2>/dev/null || echo 'N/A')"
          echo "  R2: $(r2 -v 2>/dev/null | head -1 || echo 'N/A')"

      - name: Create Working Directories
        run: |
          mkdir -p /tmp/apks
          mkdir -p /tmp/patched
          mkdir -p /tmp/decompiled
          mkdir -p /tmp/downloads
          mkdir -p /tmp/output
          mkdir -p /tmp/logs
          echo "âœ… Working directories created"

      - name: Start Remote Executor Server
        run: |
          cat > /tmp/android_security_executor.py << 'SERVEREOF'
          #!/usr/bin/env python3
          """
          Android Security Testing Remote Executor
          Complete toolkit for APK analysis including DexGuard support
          """
          
          import os
          import sys
          import json
          import time
          import asyncio
          import subprocess
          import traceback
          import shutil
          import base64
          import hashlib
          from io import StringIO
          from typing import Optional, Dict, Any, List
          from contextlib import redirect_stdout, redirect_stderr
          from pathlib import Path
          
          from fastapi import FastAPI, HTTPException, UploadFile, File, Form
          from fastapi.middleware.cors import CORSMiddleware
          from fastapi.responses import FileResponse, JSONResponse
          from pydantic import BaseModel
          import frida
          
          app = FastAPI(
              title="Android Security Testing Executor",
              description="Complete toolkit for APK security analysis",
              version="3.0.0"
          )
          
          app.add_middleware(
              CORSMiddleware,
              allow_origins=["*"],
              allow_credentials=True,
              allow_methods=["*"],
              allow_headers=["*"],
          )
          
          # Configuration
          ADB_DEVICE = "localhost:5555"
          WORK_DIR = Path("/tmp")
          APK_DIR = WORK_DIR / "apks"
          PATCHED_DIR = WORK_DIR / "patched"
          DECOMPILED_DIR = WORK_DIR / "decompiled"
          SCRIPTS_DIR = WORK_DIR / "frida-scripts"
          OUTPUT_DIR = WORK_DIR / "output"
          
          # Global state
          execution_namespace = {"__builtins__": __builtins__}
          frida_device = None
          frida_session = None
          frida_scripts = {}
          
          class CodeRequest(BaseModel):
              code: str
              timeout: Optional[int] = 300
          
          class BashRequest(BaseModel):
              command: str
              timeout: Optional[int] = 300
          
          class ADBRequest(BaseModel):
              command: str
              timeout: Optional[int] = 60
          
          class FridaScriptRequest(BaseModel):
              script: str
              process_name: Optional[str] = "Gadget"
              script_name: Optional[str] = "default"
          
          class APKPatchRequest(BaseModel):
              apk_path: str
              architecture: str = "x86_64"
              gadget_config: Optional[str] = None
          
          class DecompileRequest(BaseModel):
              apk_path: str
              tool: str = "jadx"
              output_dir: Optional[str] = None
          
          # ============== Core Endpoints ==============
          
          @app.get("/")
          def root():
              return {
                  "service": "Android Security Testing Executor",
                  "version": "3.0.0",
                  "status": "online",
                  "tools": {
                      "decompilers": ["jadx", "cfr", "procyon", "apktool"],
                      "converters": ["dex2jar", "enjarify", "smali", "baksmali"],
                      "analysis": ["apkid", "androguard", "radare2", "quark"],
                      "instrumentation": ["frida", "objection"],
                      "utilities": ["apksigner", "zipalign", "aapt2"]
                  },
                  "endpoints": {
                      "system": ["/health", "/disk", "/tools"],
                      "execution": ["/execute", "/bash", "/adb"],
                      "apk": ["/apk/info", "/apk/patch", "/apk/install", "/apk/decompile", "/apk/identify"],
                      "frida": ["/frida/connect", "/frida/script", "/frida/ssl-bypass", "/frida/root-bypass"],
                      "files": ["/upload", "/download", "/ls", "/read"]
                  }
              }
          
          @app.get("/health")
          def health():
              import psutil
              adb_result = subprocess.run(["adb", "devices"], capture_output=True, text=True)
              emulator_ok = "localhost:5555" in adb_result.stdout or "emulator" in adb_result.stdout
              
              return {
                  "status": "healthy",
                  "cpu_percent": psutil.cpu_percent(),
                  "memory_percent": psutil.virtual_memory().percent,
                  "disk_free_gb": round(psutil.disk_usage('/').free / (1024**3), 2),
                  "emulator_connected": emulator_ok,
                  "frida_version": frida.__version__,
                  "frida_session_active": frida_session is not None,
                  "adb_device": ADB_DEVICE
              }
          
          @app.get("/tools")
          def list_tools():
              """List all installed tools and versions"""
              tools = {}
              checks = [
                  ("apktool", ["apktool", "--version"]),
                  ("jadx", ["jadx", "--version"]),
                  ("frida", ["frida", "--version"]),
                  ("objection", ["objection", "version"]),
                  ("apkid", ["apkid", "--version"]),
                  ("r2", ["r2", "-v"]),
                  ("dex2jar", ["d2j-dex2jar", "--help"]),
                  ("smali", ["java", "-jar", "/usr/local/bin/smali.jar", "--version"]),
                  ("cfr", ["java", "-jar", "/usr/local/bin/cfr.jar", "--version"]),
                  ("aapt2", ["aapt2", "version"]),
                  ("apksigner", ["apksigner", "--version"]),
              ]
              
              for name, cmd in checks:
                  try:
                      result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
                      output = (result.stdout + result.stderr).strip().split('\n')[0][:100]
                      tools[name] = {"installed": True, "version": output}
                  except:
                      tools[name] = {"installed": False, "version": None}
              
              return {"success": True, "tools": tools}
          
          # ============== Code Execution ==============
          
          @app.post("/execute")
          def execute_code(request: CodeRequest):
              stdout_capture = StringIO()
              stderr_capture = StringIO()
              result = None
              error = None
              
              try:
                  with redirect_stdout(stdout_capture), redirect_stderr(stderr_capture):
                      exec(request.code, execution_namespace)
                      lines = request.code.strip().split('\n')
                      if lines:
                          last = lines[-1].strip()
                          if last and not any(last.startswith(k) for k in 
                              ['import', 'from', 'def', 'class', 'if', 'for', 'while', 'with', 'try', '#', 'print', '=']):
                              try:
                                  result = eval(last, execution_namespace)
                              except:
                                  pass
              except Exception as e:
                  error = f"{type(e).__name__}: {str(e)}\n{traceback.format_exc()}"
              
              return {
                  "success": error is None,
                  "stdout": stdout_capture.getvalue(),
                  "stderr": stderr_capture.getvalue(),
                  "result": repr(result) if result is not None else None,
                  "error": error
              }
          
          @app.post("/bash")
          def execute_bash(request: BashRequest):
              try:
                  result = subprocess.run(
                      request.command, shell=True, capture_output=True, text=True,
                      timeout=request.timeout, env={**os.environ, "PATH": os.environ.get("PATH", "") + ":/usr/local/bin"}
                  )
                  return {
                      "success": result.returncode == 0,
                      "returncode": result.returncode,
                      "stdout": result.stdout,
                      "stderr": result.stderr
                  }
              except subprocess.TimeoutExpired:
                  return {"success": False, "error": f"Timeout after {request.timeout}s"}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          # ============== ADB ==============
          
          @app.post("/adb")
          def execute_adb(request: ADBRequest):
              try:
                  cmd = f"adb -s {ADB_DEVICE} {request.command}"
                  result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=request.timeout)
                  return {
                      "success": result.returncode == 0,
                      "command": cmd,
                      "stdout": result.stdout,
                      "stderr": result.stderr
                  }
              except subprocess.TimeoutExpired:
                  return {"success": False, "error": f"Timeout after {request.timeout}s"}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.get("/adb/devices")
          def adb_devices():
              result = subprocess.run(["adb", "devices", "-l"], capture_output=True, text=True)
              lines = result.stdout.strip().split('\n')[1:]
              devices = []
              for line in lines:
                  if line.strip():
                      parts = line.split()
                      if len(parts) >= 2:
                          devices.append({"id": parts[0], "state": parts[1], "info": ' '.join(parts[2:])})
              return {"success": True, "devices": devices}
          
          @app.get("/adb/packages")
          def adb_packages(filter: Optional[str] = None):
              cmd = f"adb -s {ADB_DEVICE} shell pm list packages"
              if filter:
                  cmd += f" | grep -i {filter}"
              result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
              packages = [p.replace("package:", "") for p in result.stdout.strip().split('\n') if p]
              return {"success": True, "packages": packages, "count": len(packages)}
          
          # ============== APK Operations ==============
          
          @app.get("/apk/info")
          def apk_info(apk_path: str):
              try:
                  # Use aapt2 from build-tools
                  aapt_paths = [
                      "/usr/local/lib/android/sdk/build-tools/34.0.0/aapt2",
                      "/usr/local/lib/android/sdk/build-tools/33.0.2/aapt2",
                      "aapt2", "aapt"
                  ]
                  
                  result = None
                  for aapt in aapt_paths:
                      try:
                          result = subprocess.run(f"{aapt} dump badging {apk_path}", shell=True, capture_output=True, text=True, timeout=30)
                          if result.returncode == 0:
                              break
                      except:
                          continue
                  
                  if not result or result.returncode != 0:
                      result = subprocess.run(f"aapt dump badging {apk_path}", shell=True, capture_output=True, text=True)
                  
                  info = {"raw": result.stdout[:5000]}
                  
                  for line in result.stdout.split('\n'):
                      if line.startswith("package:"):
                          parts = line.split("'")
                          info["package_name"] = parts[1] if len(parts) > 1 else None
                          info["version_code"] = parts[3] if len(parts) > 3 else None
                          info["version_name"] = parts[5] if len(parts) > 5 else None
                      elif line.startswith("application-label:"):
                          info["app_name"] = line.split("'")[1] if "'" in line else None
                      elif line.startswith("sdkVersion:"):
                          info["min_sdk"] = line.split("'")[1] if "'" in line else None
                      elif line.startswith("targetSdkVersion:"):
                          info["target_sdk"] = line.split("'")[1] if "'" in line else None
                  
                  # Get file hash
                  with open(apk_path, 'rb') as f:
                      info["sha256"] = hashlib.sha256(f.read()).hexdigest()
                  info["size_mb"] = round(os.path.getsize(apk_path) / (1024*1024), 2)
                  
                  return {"success": True, "info": info}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.get("/apk/identify")
          def apk_identify(apk_path: str):
              """Identify protections using APKiD"""
              try:
                  result = subprocess.run(
                      f"apkid -j {apk_path}",
                      shell=True, capture_output=True, text=True, timeout=120
                  )
                  
                  if result.returncode == 0:
                      try:
                          data = json.loads(result.stdout)
                          return {"success": True, "apkid": data}
                      except:
                          return {"success": True, "apkid_raw": result.stdout}
                  else:
                      return {"success": False, "error": result.stderr, "stdout": result.stdout}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/apk/patch")
          def patch_apk(request: APKPatchRequest):
              """Patch APK with Frida Gadget"""
              try:
                  apk_path = Path(request.apk_path)
                  if not apk_path.exists():
                      return {"success": False, "error": f"APK not found: {apk_path}"}
                  
                  # Set PATH to include build-tools
                  env = os.environ.copy()
                  env["PATH"] = f"/usr/local/lib/android/sdk/build-tools/34.0.0:{env.get('PATH', '')}"
                  
                  cmd = f"objection patchapk -s {apk_path} -a {request.architecture}"
                  
                  result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=300, env=env)
                  
                  patched_name = apk_path.stem + ".objection.apk"
                  patched_path = apk_path.parent / patched_name
                  
                  if patched_path.exists() and patched_path.stat().st_size > 0:
                      # Verify Frida Gadget is in the APK
                      check = subprocess.run(f"unzip -l {patched_path} | grep -i frida", shell=True, capture_output=True, text=True)
                      has_gadget = "frida" in check.stdout.lower()
                      
                      return {
                          "success": True,
                          "original_apk": str(apk_path),
                          "patched_apk": str(patched_path),
                          "size_mb": round(patched_path.stat().st_size / (1024*1024), 2),
                          "has_frida_gadget": has_gadget,
                          "stdout": result.stdout[-2000:] if result.stdout else "",
                          "stderr": result.stderr[-1000:] if result.stderr else ""
                      }
                  else:
                      return {
                          "success": False,
                          "error": "Patching failed - output file not created or empty",
                          "stdout": result.stdout,
                          "stderr": result.stderr
                      }
              except subprocess.TimeoutExpired:
                  return {"success": False, "error": "Patching timed out after 300s"}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/apk/patch-manual")
          def patch_apk_manual(request: APKPatchRequest):
              """Manual APK patching with more control (for difficult APKs)"""
              try:
                  apk_path = Path(request.apk_path)
                  if not apk_path.exists():
                      return {"success": False, "error": f"APK not found"}
                  
                  work_dir = PATCHED_DIR / f"manual_{int(time.time())}"
                  work_dir.mkdir(parents=True, exist_ok=True)
                  
                  steps = []
                  
                  # Step 1: Decompile with apktool
                  decompiled = work_dir / "decompiled"
                  cmd = f"apktool d -f -o {decompiled} {apk_path}"
                  result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=120)
                  steps.append({"step": "decompile", "success": result.returncode == 0, "output": result.stderr[:500]})
                  
                  if result.returncode != 0:
                      return {"success": False, "error": "Decompilation failed", "steps": steps}
                  
                  # Step 2: Download Frida Gadget
                  gadget_dir = work_dir / "gadget"
                  gadget_dir.mkdir(exist_ok=True)
                  
                  frida_version = frida.__version__
                  arch = request.architecture
                  gadget_url = f"https://github.com/frida/frida/releases/download/{frida_version}/frida-gadget-{frida_version}-android-{arch}.so.xz"
                  
                  gadget_path = gadget_dir / f"libfrida-gadget.so"
                  cmd = f"wget -q {gadget_url} -O {gadget_dir}/gadget.so.xz && xz -d {gadget_dir}/gadget.so.xz && mv {gadget_dir}/gadget.so {gadget_path}"
                  result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=60)
                  steps.append({"step": "download_gadget", "success": result.returncode == 0})
                  
                  if not gadget_path.exists():
                      return {"success": False, "error": "Failed to download Frida Gadget", "steps": steps}
                  
                  # Step 3: Add gadget to lib directory
                  lib_dir = decompiled / "lib" / arch
                  lib_dir.mkdir(parents=True, exist_ok=True)
                  shutil.copy(gadget_path, lib_dir / "libfrida-gadget.so")
                  steps.append({"step": "copy_gadget", "success": True})
                  
                  # Step 4: Modify smali to load gadget
                  # Find main activity
                  manifest = decompiled / "AndroidManifest.xml"
                  with open(manifest, 'r') as f:
                      manifest_content = f.read()
                  
                  # Simple injection - add to Application class or main activity
                  smali_dirs = list(decompiled.glob("smali*/"))
                  injection_done = False
                  
                  for smali_dir in smali_dirs:
                      for smali_file in smali_dir.rglob("*.smali"):
                          with open(smali_file, 'r') as f:
                              content = f.read()
                          
                          if ".method public constructor <init>" in content or ".method public onCreate" in content:
                              # Inject loadLibrary call
                              if 'const-string v0, "frida-gadget"' not in content:
                                  injection = '''
          .method static constructor <clinit>()V
              .locals 1
              const-string v0, "frida-gadget"
              invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
              return-void
          .end method
          '''
                                  if ".method static constructor <clinit>" not in content:
                                      content = content.replace(".super", injection + "\n.super", 1)
                                      with open(smali_file, 'w') as f:
                                          f.write(content)
                                      injection_done = True
                                      steps.append({"step": "inject_smali", "success": True, "file": str(smali_file)})
                                      break
                          if injection_done:
                              break
                      if injection_done:
                          break
                  
                  # Step 5: Rebuild APK
                  rebuilt = work_dir / "rebuilt.apk"
                  cmd = f"apktool b {decompiled} -o {rebuilt}"
                  result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=120)
                  steps.append({"step": "rebuild", "success": result.returncode == 0, "output": result.stderr[:500]})
                  
                  if not rebuilt.exists():
                      return {"success": False, "error": "Rebuild failed", "steps": steps}
                  
                  # Step 6: Sign APK
                  signed = work_dir / "signed.apk"
                  
                  # Create keystore if needed
                  keystore = work_dir / "debug.keystore"
                  cmd = f'keytool -genkey -v -keystore {keystore} -alias androiddebugkey -keyalg RSA -keysize 2048 -validity 10000 -storepass android -keypass android -dname "CN=Android Debug,O=Android,C=US"'
                  subprocess.run(cmd, shell=True, capture_output=True, timeout=30)
                  
                  # Align
                  aligned = work_dir / "aligned.apk"
                  cmd = f"zipalign -v 4 {rebuilt} {aligned}"
                  subprocess.run(cmd, shell=True, capture_output=True, timeout=30)
                  
                  # Sign
                  cmd = f"apksigner sign --ks {keystore} --ks-pass pass:android --key-pass pass:android --out {signed} {aligned}"
                  result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
                  steps.append({"step": "sign", "success": result.returncode == 0})
                  
                  if signed.exists():
                      final_path = PATCHED_DIR / f"{apk_path.stem}.patched.apk"
                      shutil.copy(signed, final_path)
                      
                      return {
                          "success": True,
                          "original_apk": str(apk_path),
                          "patched_apk": str(final_path),
                          "steps": steps
                      }
                  else:
                      return {"success": False, "error": "Signing failed", "steps": steps}
                  
              except Exception as e:
                  return {"success": False, "error": str(e), "traceback": traceback.format_exc()}
          
          @app.post("/apk/install")
          def install_apk(apk_path: str):
              try:
                  result = subprocess.run(
                      f"adb -s {ADB_DEVICE} install -r -g {apk_path}",
                      shell=True, capture_output=True, text=True, timeout=120
                  )
                  success = "Success" in result.stdout or result.returncode == 0
                  return {"success": success, "apk_path": apk_path, "stdout": result.stdout, "stderr": result.stderr}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/apk/launch")
          def launch_app(package_name: str):
              try:
                  result = subprocess.run(
                      f"adb -s {ADB_DEVICE} shell monkey -p {package_name} -c android.intent.category.LAUNCHER 1",
                      shell=True, capture_output=True, text=True
                  )
                  return {"success": result.returncode == 0, "package": package_name, "stdout": result.stdout, "stderr": result.stderr}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/apk/decompile")
          def decompile_apk(request: DecompileRequest):
              """Decompile APK using various tools"""
              try:
                  apk_path = Path(request.apk_path)
                  if not apk_path.exists():
                      return {"success": False, "error": "APK not found"}
                  
                  output = Path(request.output_dir) if request.output_dir else DECOMPILED_DIR / apk_path.stem
                  output.mkdir(parents=True, exist_ok=True)
                  
                  if request.tool == "jadx":
                      cmd = f"jadx -d {output} --deobf {apk_path}"
                  elif request.tool == "apktool":
                      cmd = f"apktool d -f -o {output} {apk_path}"
                  elif request.tool == "cfr":
                      # First convert to jar
                      jar_path = output / f"{apk_path.stem}.jar"
                      subprocess.run(f"d2j-dex2jar -f -o {jar_path} {apk_path}", shell=True, timeout=120)
                      cmd = f"cfr {jar_path} --outputdir {output}/src"
                  elif request.tool == "enjarify":
                      jar_path = output / f"{apk_path.stem}.jar"
                      cmd = f"enjarify {apk_path} -o {jar_path}"
                  else:
                      return {"success": False, "error": f"Unknown tool: {request.tool}"}
                  
                  result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=300)
                  
                  return {
                      "success": result.returncode == 0,
                      "tool": request.tool,
                      "output_dir": str(output),
                      "stdout": result.stdout[-2000:],
                      "stderr": result.stderr[-1000:]
                  }
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          # ============== Frida Operations ==============
          
          @app.post("/frida/connect")
          def frida_connect():
              global frida_device
              try:
                  subprocess.run(["adb", "-s", ADB_DEVICE, "forward", "tcp:27042", "tcp:27042"], check=True)
                  frida_device = frida.get_device_manager().add_remote_device("127.0.0.1:27042")
                  return {"success": True, "device": str(frida_device), "message": "Connected"}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.get("/frida/processes")
          def frida_processes():
              global frida_device
              if not frida_device:
                  return {"success": False, "error": "Not connected"}
              try:
                  procs = frida_device.enumerate_processes()
                  return {"success": True, "processes": [{"pid": p.pid, "name": p.name} for p in procs]}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/frida/attach")
          def frida_attach(process_name: str = "Gadget"):
              global frida_device, frida_session
              if not frida_device:
                  r = frida_connect()
                  if not r.get("success"):
                      return r
              try:
                  frida_session = frida_device.attach(process_name)
                  return {"success": True, "message": f"Attached to {process_name}"}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/frida/script")
          def frida_load_script(request: FridaScriptRequest):
              global frida_session, frida_scripts
              if not frida_session:
                  r = frida_attach(request.process_name)
                  if not r.get("success"):
                      return r
              
              messages = []
              def on_message(msg, data):
                  messages.append(msg)
              
              try:
                  script = frida_session.create_script(request.script)
                  script.on('message', on_message)
                  script.load()
                  frida_scripts[request.script_name] = script
                  time.sleep(0.5)
                  return {"success": True, "script_name": request.script_name, "messages": messages}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/frida/script-file")
          def frida_load_script_file(script_path: str, process_name: str = "Gadget"):
              try:
                  with open(script_path, 'r') as f:
                      script_content = f.read()
                  return frida_load_script(FridaScriptRequest(
                      script=script_content,
                      process_name=process_name,
                      script_name=Path(script_path).stem
                  ))
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/frida/ssl-bypass")
          def frida_ssl_bypass(process_name: str = "Gadget"):
              script_path = "/tmp/frida-scripts/ssl_bypass_universal.js"
              if os.path.exists(script_path):
                  return frida_load_script_file(script_path, process_name)
              return {"success": False, "error": "SSL bypass script not found"}
          
          @app.post("/frida/root-bypass")
          def frida_root_bypass(process_name: str = "Gadget"):
              script_path = "/tmp/frida-scripts/root_bypass_universal.js"
              if os.path.exists(script_path):
                  return frida_load_script_file(script_path, process_name)
              return {"success": False, "error": "Root bypass script not found"}
          
          @app.post("/frida/anti-debug-bypass")
          def frida_debug_bypass(process_name: str = "Gadget"):
              script_path = "/tmp/frida-scripts/anti_debug_bypass.js"
              if os.path.exists(script_path):
                  return frida_load_script_file(script_path, process_name)
              return {"success": False, "error": "Anti-debug bypass script not found"}
          
          @app.post("/frida/dexguard-strings")
          def frida_dexguard_strings(process_name: str = "Gadget"):
              script_path = "/tmp/frida-scripts/dexguard_strings.js"
              if os.path.exists(script_path):
                  return frida_load_script_file(script_path, process_name)
              return {"success": False, "error": "DexGuard strings script not found"}
          
          @app.get("/frida/scripts")
          def frida_list_scripts():
              return {"success": True, "scripts": list(frida_scripts.keys())}
          
          @app.get("/frida/scripts-available")
          def frida_available_scripts():
              scripts = []
              for f in Path("/tmp/frida-scripts").glob("*.js"):
                  scripts.append({"name": f.stem, "path": str(f)})
              return {"success": True, "scripts": scripts}
          
          # ============== File Operations ==============
          
          @app.post("/upload")
          async def upload_file(file: UploadFile = File(...), destination: str = Form(default="/tmp/apks")):
              try:
                  dest = Path(destination)
                  dest.mkdir(parents=True, exist_ok=True)
                  filepath = dest / file.filename
                  
                  content = await file.read()
                  with open(filepath, "wb") as f:
                      f.write(content)
                  
                  return {"success": True, "filepath": str(filepath), "size_bytes": len(content)}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/download")
          def download_file(url: str, destination: str = "/tmp/downloads", filename: Optional[str] = None):
              try:
                  dest = Path(destination)
                  dest.mkdir(parents=True, exist_ok=True)
                  
                  fname = filename or url.split('/')[-1].split('?')[0]
                  filepath = dest / fname
                  
                  result = subprocess.run(f'curl -L -o "{filepath}" "{url}"', shell=True, capture_output=True, timeout=600)
                  
                  if filepath.exists() and filepath.stat().st_size > 0:
                      return {"success": True, "filepath": str(filepath), "size_mb": round(filepath.stat().st_size / (1024*1024), 2)}
                  return {"success": False, "error": "Download failed"}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.get("/ls")
          def list_dir(path: str = "/tmp"):
              try:
                  p = Path(path)
                  if not p.exists():
                      return {"success": False, "error": "Path not found"}
                  items = [{"name": i.name, "is_dir": i.is_dir(), "size": i.stat().st_size if i.is_file() else None} for i in p.iterdir()]
                  return {"success": True, "path": path, "items": items}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.get("/read")
          def read_file(path: str, max_size: int = 1048576):
              try:
                  p = Path(path)
                  if not p.exists():
                      return {"success": False, "error": "File not found"}
                  if p.stat().st_size > max_size:
                      return {"success": False, "error": f"File too large (>{max_size} bytes)"}
                  with open(p, 'r') as f:
                      return {"success": True, "path": path, "content": f.read()}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.get("/disk")
          def disk_usage():
              import shutil
              total, used, free = shutil.disk_usage("/")
              return {
                  "total_gb": round(total / (1024**3), 2),
                  "used_gb": round(used / (1024**3), 2),
                  "free_gb": round(free / (1024**3), 2),
                  "percent_used": round(used / total * 100, 1)
              }
          
          if __name__ == "__main__":
              import uvicorn
              uvicorn.run(app, host="0.0.0.0", port=8000)
          SERVEREOF
          
          echo "âœ… Remote executor server created"

      - name: Start ngrok and Server
        run: |
          PORT=${{ inputs.server_port }}
          
          # Start server
          python3 /tmp/android_security_executor.py &
          SERVER_PID=$!
          echo "SERVER_PID=$SERVER_PID" >> $GITHUB_ENV
          sleep 5
          
          # Verify server
          curl -s http://localhost:$PORT/health || { echo "Server failed to start"; exit 1; }
          
          # Start ngrok
          ngrok http $PORT --log=stdout > /tmp/ngrok.log 2>&1 &
          NGROK_PID=$!
          echo "NGROK_PID=$NGROK_PID" >> $GITHUB_ENV
          sleep 5
          
          # Get URL
          NGROK_URL=$(curl -s http://localhost:4040/api/tunnels | jq -r '.tunnels[0].public_url')
          
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ðŸŽ¯ ANDROID SECURITY TOOLKIT READY!"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ðŸ“¡ PUBLIC URL: $NGROK_URL"
          echo ""
          echo "ðŸ”§ Available Tools:"
          echo "   â€¢ Decompilers: JADX, CFR, Procyon, APKTool"
          echo "   â€¢ Analysis: APKiD, Androguard, Radare2"
          echo "   â€¢ Instrumentation: Frida ${frida --version}, Objection"
          echo "   â€¢ Utilities: smali/baksmali, dex2jar, enjarify"
          echo ""
          echo "ðŸ“š API Docs: $NGROK_URL/docs"
          echo "â° Session: ${{ inputs.session_duration }} minutes"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""

      - name: Keep Session Alive
        run: |
          duration=${{ inputs.session_duration }}
          elapsed=0
          interval=60
          
          while [ $elapsed -lt $((duration * 60)) ]; do
            sleep $interval
            elapsed=$((elapsed + interval))
            
            emu="âŒ"
            srv="âŒ"
            
            if adb -s localhost:5555 shell getprop sys.boot_completed 2>/dev/null | grep -q "1"; then
              emu="âœ…"
            fi
            
            if curl -s http://localhost:${{ inputs.server_port }}/health | grep -q "healthy"; then
              srv="âœ…"
            fi
            
            echo "[$(date +%H:%M:%S)] Emulator: $emu | Server: $srv | ${elapsed}s / $((duration * 60))s"
          done
          
          echo "â° Session ended"

      - name: Cleanup
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up..."
          ngrok kill 2>/dev/null || true
          kill $EMULATOR_PID 2>/dev/null || true
          kill $SERVER_PID 2>/dev/null || true
          adb -s localhost:5555 emu kill 2>/dev/null || true
          adb kill-server 2>/dev/null || true
          echo "âœ… Done"
