name: Android Security Testing - Claude Frida Controller v4.0

on:
  workflow_dispatch:
    inputs:
      session_duration:
        description: 'Session duration in minutes'
        required: true
        default: '45'
        type: choice
        options:
          - '15'
          - '30'
          - '45'
          - '60'
          - '90'
          - '120'
      android_api:
        description: 'Android API level'
        required: true
        default: '31'
        type: choice
        options:
          - '29'
          - '30'
          - '31'
          - '33'
      server_port:
        description: 'Server port'
        required: true
        default: '8000'
      enable_advanced_tools:
        description: 'Install advanced tools (radare2, APKiD)'
        required: true
        default: true
        type: boolean

env:
  ANDROID_AVD_HOME: /home/runner/.android/avd
  ANDROID_SDK_ROOT: /usr/local/lib/android/sdk
  ANDROID_HOME: /usr/local/lib/android/sdk
  JAVA_HOME: /usr/lib/jvm/temurin-17-jdk-amd64
  ANDROID_API: ${{ inputs.android_api }}
  SERVER_PORT: ${{ inputs.server_port }}
  WORK_DIR: /tmp/android_security
  APK_DIR: /tmp/android_security/apks
  OUTPUT_DIR: /tmp/android_security/output
  SCRIPTS_DIR: /tmp/android_security/scripts
  LOGS_DIR: /tmp/android_security/logs

jobs:
  android-security-session:
    runs-on: ubuntu-latest
    timeout-minutes: 125

    steps:
      # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
      # â•‘  PHASE 1: SYSTEM SETUP                                                      â•‘
      # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      - name: System Information
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘  ðŸ¤– CLAUDE ANDROID FRIDA CONTROLLER v4.0                       â•‘"
          echo "â•‘  Android Security Testing with Remote Control                  â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ðŸ“‹ Configuration:"
          echo "   Runner: $(uname -a)"
          echo "   CPU: $(nproc) cores"
          echo "   RAM: $(free -h | grep Mem | awk '{print $2}')"
          echo "   Disk: $(df -h / | tail -1 | awk '{print $4}') available"
          echo "   Android API: ${{ inputs.android_api }}"
          echo "   Session Duration: ${{ inputs.session_duration }} minutes"
          echo "   Server Port: ${{ inputs.server_port }}"
          echo ""

      - name: Enable KVM Acceleration
        run: |
          echo 'KERNEL=="kvm", GROUP="kvm", MODE="0666", OPTIONS+="static_node=kvm"' | sudo tee /etc/udev/rules.d/99-kvm4all.rules
          sudo udevadm control --reload-rules
          sudo udevadm trigger --name-match=kvm
          ls -la /dev/kvm
          echo "âœ… KVM enabled"

      - name: Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install System Dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq \
            wget curl unzip zip git jq \
            build-essential cmake pkg-config \
            libssl-dev libffi-dev libxml2-dev libxslt1-dev \
            zlib1g-dev libjpeg-dev libpng-dev \
            android-tools-adb android-tools-fastboot \
            aapt apksigner zipalign \
            openjdk-17-jdk graphviz \
            libc6-i386 lib32stdc++6 lib32z1 \
            qemu-kvm libvirt-daemon-system \
            xz-utils p7zip-full
          echo "âœ… System dependencies installed"

      # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
      # â•‘  PHASE 2: ANDROID SDK SETUP                                                 â•‘
      # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      - name: Configure Android SDK Paths
        run: |
          echo "$ANDROID_HOME/cmdline-tools/latest/bin" >> $GITHUB_PATH
          echo "$ANDROID_HOME/platform-tools" >> $GITHUB_PATH
          echo "$ANDROID_HOME/emulator" >> $GITHUB_PATH
          echo "$ANDROID_HOME/build-tools/34.0.0" >> $GITHUB_PATH
          echo "âœ… Android SDK paths configured"

      - name: Initialize Android Directory Structure
        run: |
          echo "=== Creating Android directory structure ==="
          mkdir -p /home/runner/.android/avd
          mkdir -p /home/runner/.android/cache
          chmod -R 755 /home/runner/.android
          echo "Verifying directory structure:"
          ls -la /home/runner/.android/
          echo "ANDROID_AVD_HOME=/home/runner/.android/avd" >> $GITHUB_ENV
          echo "ANDROID_USER_HOME=/home/runner/.android" >> $GITHUB_ENV
          echo "âœ… Android directory structure created"

      - name: Install Android SDK Components
        run: |
          SDKMANAGER="$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager"
          
          echo "=== Accepting Licenses ==="
          yes | $SDKMANAGER --licenses > /dev/null 2>&1 || true
          
          echo "=== Installing Build Tools ==="
          $SDKMANAGER --install "build-tools;34.0.0" "build-tools;33.0.2" "build-tools;30.0.3"
          
          echo "=== Installing Platform Tools ==="
          $SDKMANAGER --install "platform-tools"
          
          echo "=== Installing Emulator ==="
          $SDKMANAGER --install "emulator"
          
          echo "=== Installing Platform for API ${{ inputs.android_api }} ==="
          $SDKMANAGER --install "platforms;android-${{ inputs.android_api }}"
          
          echo "=== Installing System Image (PlayStore for rootAVD) ==="
          $SDKMANAGER --install "system-images;android-${{ inputs.android_api }};google_apis_playstore;x86_64"
          
          echo "=== Verifying Installation ==="
          $SDKMANAGER --list_installed | grep -E "system-images|build-tools|platform-tools|emulator" || true
          
          echo "=== Verifying System Image Path ==="
          SYSIMG_PATH="$ANDROID_HOME/system-images/android-${{ inputs.android_api }}/google_apis_playstore/x86_64"
          if [ -d "$SYSIMG_PATH" ]; then
            echo "âœ… System image found at: $SYSIMG_PATH"
            ls -la "$SYSIMG_PATH"
          else
            echo "âŒ ERROR: System image NOT found at: $SYSIMG_PATH"
            find $ANDROID_HOME/system-images -type d -name "x86_64" 2>/dev/null | head -10
            exit 1
          fi
          
          adb version
          echo "âœ… Android SDK components installed"

      # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
      # â•‘  PHASE 3: SECURITY TOOLS INSTALLATION                                       â•‘
      # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      - name: Install APKTool
        run: |
          APKTOOL_VERSION="2.9.3"
          sudo wget -q "https://github.com/iBotPeaches/Apktool/releases/download/v${APKTOOL_VERSION}/apktool_${APKTOOL_VERSION}.jar" -O /usr/local/bin/apktool.jar
          sudo wget -q "https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/linux/apktool" -O /usr/local/bin/apktool
          sudo chmod +x /usr/local/bin/apktool
          apktool --version
          echo "âœ… APKTool installed"

      - name: Install JADX
        run: |
          JADX_VERSION="1.5.0"
          wget -q "https://github.com/skylot/jadx/releases/download/v${JADX_VERSION}/jadx-${JADX_VERSION}.zip" -O jadx.zip
          sudo unzip -q jadx.zip -d /opt/jadx
          sudo ln -sf /opt/jadx/bin/jadx /usr/local/bin/jadx
          sudo ln -sf /opt/jadx/bin/jadx-gui /usr/local/bin/jadx-gui
          jadx --version
          echo "âœ… JADX installed"

      - name: Install Python Security Tools
        run: |
          pip install --upgrade pip
          pip install frida-tools objection androguard lief --break-system-packages
          
          # Install uber-apk-signer
          UBER_VERSION="1.3.0"
          wget -q "https://github.com/nicoboss/uber-apk-signer/releases/download/v${UBER_VERSION}/uber-apk-signer-${UBER_VERSION}.jar" -O /tmp/uber-apk-signer.jar
          sudo mv /tmp/uber-apk-signer.jar /usr/local/bin/
          
          # Verify
          frida --version
          objection version || echo "Objection installed"
          echo "âœ… Python security tools installed"

      - name: Install Advanced Tools
        if: ${{ inputs.enable_advanced_tools }}
        run: |
          # Install radare2
          sudo apt-get install -y -qq radare2 || {
            git clone --depth=1 https://github.com/radareorg/radare2.git /tmp/radare2
            cd /tmp/radare2 && sys/install.sh
          }
          
          # Install APKiD
          pip install apkid --break-system-packages || echo "APKiD install attempted"
          
          echo "âœ… Advanced tools installed"

      - name: Install FastAPI Server Dependencies
        run: |
          pip install fastapi uvicorn pyngrok httpx aiofiles python-multipart psutil --break-system-packages
          echo "âœ… FastAPI server dependencies installed"

      # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
      # â•‘  PHASE 4: CREATE WORKING DIRECTORIES & FRIDA SCRIPTS                        â•‘
      # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      - name: Create Working Directories
        run: |
          mkdir -p $WORK_DIR
          mkdir -p $APK_DIR
          mkdir -p $OUTPUT_DIR
          mkdir -p $SCRIPTS_DIR
          mkdir -p $LOGS_DIR
          echo "âœ… Working directories created"

      - name: Create Frida Bypass Scripts
        run: |
          # Root Detection Bypass Script
          cat > $SCRIPTS_DIR/root_bypass.js << 'ROOTBYPASS'
          // Root Detection Bypass - Comprehensive
          Java.perform(function() {
              console.log("[*] Root Detection Bypass loaded");
              
              // Hook File.exists for common root paths
              var File = Java.use("java.io.File");
              File.exists.implementation = function() {
                  var path = this.getAbsolutePath();
                  var rootPaths = ["/system/app/Superuser.apk", "/system/xbin/su", "/system/bin/su",
                      "/sbin/su", "/data/local/xbin/su", "/data/local/bin/su", "/data/local/su",
                      "/system/sd/xbin/su", "/system/bin/failsafe/su", "/su/bin/su", "/magisk"];
                  for (var i = 0; i < rootPaths.length; i++) {
                      if (path.indexOf(rootPaths[i]) !== -1) {
                          console.log("[+] Hiding root path: " + path);
                          return false;
                      }
                  }
                  return this.exists();
              };
              
              // Hook Runtime.exec for su commands
              var Runtime = Java.use("java.lang.Runtime");
              Runtime.exec.overload('java.lang.String').implementation = function(cmd) {
                  if (cmd.indexOf("su") !== -1 || cmd.indexOf("which") !== -1) {
                      console.log("[+] Blocking exec: " + cmd);
                      throw new Error("Command not found");
                  }
                  return this.exec(cmd);
              };
              
              // Hook Build properties
              var Build = Java.use("android.os.Build");
              Build.TAGS.value = "release-keys";
              Build.FINGERPRINT.value = Build.FINGERPRINT.value.replace("test-keys", "release-keys");
              
              console.log("[*] Root detection bypass active");
          });
          ROOTBYPASS
          
          # SSL Pinning Bypass Script
          cat > $SCRIPTS_DIR/ssl_bypass.js << 'SSLBYPASS'
          // SSL Pinning Bypass - Universal
          Java.perform(function() {
              console.log("[*] SSL Pinning Bypass loaded");
              
              // TrustManager bypass
              var TrustManager = Java.registerClass({
                  name: 'com.frida.TrustManager',
                  implements: [Java.use('javax.net.ssl.X509TrustManager')],
                  methods: {
                      checkClientTrusted: function(chain, authType) {},
                      checkServerTrusted: function(chain, authType) {},
                      getAcceptedIssuers: function() { return []; }
                  }
              });
              
              // SSLContext bypass
              var SSLContext = Java.use('javax.net.ssl.SSLContext');
              SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;', '[Ljavax.net.ssl.TrustManager;', 'java.security.SecureRandom').implementation = function(km, tm, sr) {
                  console.log("[+] Bypassing SSLContext.init");
                  this.init(km, [TrustManager.$new()], sr);
              };
              
              // OkHttp CertificatePinner bypass
              try {
                  var CertificatePinner = Java.use('okhttp3.CertificatePinner');
                  CertificatePinner.check.overload('java.lang.String', 'java.util.List').implementation = function(hostname, peerCertificates) {
                      console.log("[+] OkHttp bypass for: " + hostname);
                  };
                  CertificatePinner.check.overload('java.lang.String', '[Ljava.security.cert.Certificate;').implementation = function(hostname, certs) {
                      console.log("[+] OkHttp bypass for: " + hostname);
                  };
              } catch(e) {}
              
              // WebViewClient bypass
              try {
                  var WebViewClient = Java.use('android.webkit.WebViewClient');
                  WebViewClient.onReceivedSslError.implementation = function(view, handler, error) {
                      console.log("[+] WebView SSL error bypassed");
                      handler.proceed();
                  };
              } catch(e) {}
              
              console.log("[*] SSL pinning bypass active");
          });
          SSLBYPASS
          
          # Emulator Detection Bypass Script
          cat > $SCRIPTS_DIR/emulator_bypass.js << 'EMUBYPASS'
          // Emulator Detection Bypass
          Java.perform(function() {
              console.log("[*] Emulator Detection Bypass loaded");
              
              var Build = Java.use("android.os.Build");
              
              // Spoof build properties
              Build.FINGERPRINT.value = "google/blueline/blueline:11/RQ3A.211001.001/7641976:user/release-keys";
              Build.MODEL.value = "Pixel 3";
              Build.MANUFACTURER.value = "Google";
              Build.BRAND.value = "google";
              Build.DEVICE.value = "blueline";
              Build.PRODUCT.value = "blueline";
              Build.HARDWARE.value = "blueline";
              Build.BOARD.value = "blueline";
              Build.HOST.value = "build.google.com";
              
              // Hide emulator-specific files
              var File = Java.use("java.io.File");
              File.exists.implementation = function() {
                  var path = this.getAbsolutePath();
                  var emuPaths = ["/dev/socket/qemud", "/dev/qemu_pipe", "/system/lib/libc_malloc_debug_qemu.so",
                      "/sys/qemu_trace", "/system/bin/qemu-props", "/dev/goldfish_pipe"];
                  for (var i = 0; i < emuPaths.length; i++) {
                      if (path.indexOf(emuPaths[i]) !== -1) {
                          console.log("[+] Hiding emulator path: " + path);
                          return false;
                      }
                  }
                  return this.exists();
              };
              
              // Spoof TelephonyManager
              try {
                  var TelephonyManager = Java.use("android.telephony.TelephonyManager");
                  TelephonyManager.getDeviceId.overload().implementation = function() {
                      return "358240051111110";
                  };
                  TelephonyManager.getSubscriberId.implementation = function() {
                      return "310260000000000";
                  };
                  TelephonyManager.getLine1Number.implementation = function() {
                      return "+15555555555";
                  };
                  TelephonyManager.getNetworkOperatorName.implementation = function() {
                      return "T-Mobile";
                  };
                  TelephonyManager.getSimOperatorName.implementation = function() {
                      return "T-Mobile";
                  };
              } catch(e) {}
              
              console.log("[*] Emulator detection bypass active");
          });
          EMUBYPASS
          
          # Frida Detection Bypass Script
          cat > $SCRIPTS_DIR/frida_bypass.js << 'FRIDABYPASS'
          // Frida Detection Bypass
          Java.perform(function() {
              console.log("[*] Frida Detection Bypass loaded");
              
              // Hide Frida port
              var Socket = Java.use("java.net.Socket");
              Socket.$init.overload("java.lang.String", "int").implementation = function(host, port) {
                  if (port === 27042 || port === 27043) {
                      console.log("[+] Blocking Frida port connection: " + port);
                      throw new Error("Connection refused");
                  }
                  return this.$init(host, port);
              };
              
              // Hide frida-server process
              var Runtime = Java.use("java.lang.Runtime");
              Runtime.exec.overload('[Ljava.lang.String;').implementation = function(cmds) {
                  for (var i = 0; i < cmds.length; i++) {
                      if (cmds[i].indexOf("frida") !== -1) {
                          console.log("[+] Blocking frida check command");
                          throw new Error("Command not found");
                      }
                  }
                  return this.exec(cmds);
              };
              
              // Hide frida libs from maps
              var BufferedReader = Java.use("java.io.BufferedReader");
              BufferedReader.readLine.overload().implementation = function() {
                  var line = this.readLine();
                  if (line !== null && (line.indexOf("frida") !== -1 || line.indexOf("gum-js-loop") !== -1)) {
                      console.log("[+] Hiding frida from maps");
                      return "";
                  }
                  return line;
              };
              
              console.log("[*] Frida detection bypass active");
          });
          FRIDABYPASS
          
          # Combined All-Bypass Script
          cat > $SCRIPTS_DIR/all_bypass.js << 'ALLBYPASS'
          // Combined All-in-One Bypass Script
          Java.perform(function() {
              console.log("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
              console.log("â•‘  ðŸ›¡ï¸ ALL SECURITY BYPASSES LOADING...                       â•‘");
              console.log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
              
              // ==================== ROOT DETECTION BYPASS ====================
              var File = Java.use("java.io.File");
              var originalExists = File.exists;
              File.exists.implementation = function() {
                  var path = this.getAbsolutePath();
                  var hidePaths = [
                      "/system/app/Superuser.apk", "/system/xbin/su", "/system/bin/su",
                      "/sbin/su", "/data/local/xbin/su", "/data/local/bin/su", "/data/local/su",
                      "/su/bin/su", "/magisk", "/dev/socket/qemud", "/dev/qemu_pipe",
                      "/system/lib/libc_malloc_debug_qemu.so", "/dev/goldfish_pipe"
                  ];
                  for (var i = 0; i < hidePaths.length; i++) {
                      if (path.indexOf(hidePaths[i]) !== -1) {
                          console.log("[ROOT/EMU] Hiding: " + path);
                          return false;
                      }
                  }
                  return originalExists.call(this);
              };
              
              // ==================== BUILD PROPERTIES SPOOF ====================
              var Build = Java.use("android.os.Build");
              Build.TAGS.value = "release-keys";
              Build.FINGERPRINT.value = "google/blueline/blueline:11/RQ3A.211001.001/7641976:user/release-keys";
              Build.MODEL.value = "Pixel 3";
              Build.MANUFACTURER.value = "Google";
              Build.BRAND.value = "google";
              Build.DEVICE.value = "blueline";
              Build.PRODUCT.value = "blueline";
              Build.HARDWARE.value = "blueline";
              console.log("[EMU] Build properties spoofed");
              
              // ==================== SSL PINNING BYPASS ====================
              var TrustManager = Java.registerClass({
                  name: 'com.bypass.TrustManager',
                  implements: [Java.use('javax.net.ssl.X509TrustManager')],
                  methods: {
                      checkClientTrusted: function(chain, authType) {},
                      checkServerTrusted: function(chain, authType) {},
                      getAcceptedIssuers: function() { return []; }
                  }
              });
              
              var SSLContext = Java.use('javax.net.ssl.SSLContext');
              SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;', '[Ljavax.net.ssl.TrustManager;', 'java.security.SecureRandom').implementation = function(km, tm, sr) {
                  console.log("[SSL] Bypassing SSLContext.init");
                  this.init(km, [TrustManager.$new()], sr);
              };
              
              try {
                  var CertificatePinner = Java.use('okhttp3.CertificatePinner');
                  CertificatePinner.check.overload('java.lang.String', 'java.util.List').implementation = function(h, p) {
                      console.log("[SSL] OkHttp bypass: " + h);
                  };
              } catch(e) {}
              
              // ==================== FRIDA DETECTION BYPASS ====================
              var Socket = Java.use("java.net.Socket");
              Socket.$init.overload("java.lang.String", "int").implementation = function(host, port) {
                  if (port === 27042 || port === 27043) {
                      console.log("[FRIDA] Blocking port: " + port);
                      throw new Error("Connection refused");
                  }
                  return this.$init(host, port);
              };
              
              console.log("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
              console.log("â•‘  âœ… ALL SECURITY BYPASSES ACTIVE                           â•‘");
              console.log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          });
          ALLBYPASS
          
          echo "âœ… Frida bypass scripts created"
          ls -la $SCRIPTS_DIR/

      # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
      # â•‘  PHASE 5: CREATE AVD AND START EMULATOR                                     â•‘
      # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      - name: Create Android Virtual Device
        run: |
          set -e
          AVDMANAGER="$ANDROID_HOME/cmdline-tools/latest/bin/avdmanager"
          AVD_NAME="security_avd"
          
          echo "=== Pre-creation Verification ==="
          echo "ANDROID_AVD_HOME: $ANDROID_AVD_HOME"
          ls -la /home/runner/.android/ || true
          
          mkdir -p "$ANDROID_AVD_HOME"
          
          echo "=== Cleaning up any existing AVD ==="
          $AVDMANAGER delete avd -n "$AVD_NAME" 2>/dev/null || true
          rm -rf "$ANDROID_AVD_HOME/${AVD_NAME}.avd" 2>/dev/null || true
          rm -f "$ANDROID_AVD_HOME/${AVD_NAME}.ini" 2>/dev/null || true
          
          echo "=== Creating AVD ==="
          echo "no" | $AVDMANAGER --verbose create avd \
            --force \
            --name "$AVD_NAME" \
            --package "system-images;android-${{ inputs.android_api }};google_apis_playstore;x86_64" \
            --device "pixel" \
            --abi "x86_64" 2>&1 || {
              echo "Trying without device specification..."
              echo "no" | $AVDMANAGER --verbose create avd \
                --force \
                --name "$AVD_NAME" \
                --package "system-images;android-${{ inputs.android_api }};google_apis_playstore;x86_64" \
                --abi "x86_64" 2>&1
            }
          
          echo "=== Post-creation Verification ==="
          if [ ! -f "$ANDROID_AVD_HOME/${AVD_NAME}.ini" ]; then
            echo "âŒ ERROR: AVD ini file NOT created!"
            echo "Contents of ANDROID_AVD_HOME:"
            ls -la "$ANDROID_AVD_HOME/" || true
            exit 1
          fi
          
          echo "âœ… AVD ini file found"
          cat "$ANDROID_AVD_HOME/${AVD_NAME}.ini"
          
          echo "=== Optimizing AVD config ==="
          AVD_CONFIG="$ANDROID_AVD_HOME/${AVD_NAME}.avd/config.ini"
          if [ -f "$AVD_CONFIG" ]; then
            echo "hw.ramSize=4096" >> "$AVD_CONFIG"
            echo "hw.keyboard=yes" >> "$AVD_CONFIG"
            echo "hw.gpu.enabled=yes" >> "$AVD_CONFIG"
            echo "hw.gpu.mode=swiftshader_indirect" >> "$AVD_CONFIG"
            echo "disk.dataPartition.size=8G" >> "$AVD_CONFIG"
          fi
          
          echo "=== Cross-verification ==="
          echo "Emulator list:"
          $ANDROID_HOME/emulator/emulator -list-avds
          echo ""
          echo "AVDManager list:"
          $AVDMANAGER list avd
          
          echo "âœ… AVD created successfully"

      - name: Start Android Emulator
        run: |
          set -e
          AVD_NAME="security_avd"
          
          echo "=== Verifying AVD exists ==="
          if ! $ANDROID_HOME/emulator/emulator -list-avds | grep -q "$AVD_NAME"; then
            echo "âŒ ERROR: AVD '$AVD_NAME' not found in emulator list!"
            echo "Available AVDs:"
            $ANDROID_HOME/emulator/emulator -list-avds
            exit 1
          fi
          echo "âœ… AVD '$AVD_NAME' found"
          
          echo "Cleaning up existing emulator processes..."
          pkill -9 -f "emulator" 2>/dev/null || true
          pkill -9 -f "qemu-system" 2>/dev/null || true
          sleep 3
          
          echo "=== Starting Emulator ==="
          export ANDROID_AVD_HOME="/home/runner/.android/avd"
          
          nohup $ANDROID_HOME/emulator/emulator \
            @${AVD_NAME} \
            -writable-system \
            -no-window \
            -no-audio \
            -no-boot-anim \
            -gpu swiftshader_indirect \
            -no-snapshot-save \
            -no-snapshot-load \
            -memory 4096 \
            -cores 2 \
            -partition-size 8192 \
            -verbose \
            2>&1 | tee $LOGS_DIR/emulator.log &
          
          EMULATOR_PID=$!
          echo "Emulator PID: $EMULATOR_PID"
          echo "EMULATOR_PID=$EMULATOR_PID" >> $GITHUB_ENV
          
          sleep 10
          
          if ! kill -0 $EMULATOR_PID 2>/dev/null; then
            echo "âŒ ERROR: Emulator process died!"
            echo "=== Emulator Log ==="
            cat $LOGS_DIR/emulator.log | tail -100
            exit 1
          fi
          
          echo "âœ… Emulator process started successfully"

      - name: Wait for Emulator Boot
        run: |
          echo "=== Waiting for Emulator ==="
          TIMEOUT=300
          ELAPSED=0
          
          echo "Waiting for ADB device..."
          while [ $ELAPSED -lt 60 ]; do
            if adb devices 2>/dev/null | grep -q "emulator-"; then
              echo "âœ… ADB device detected after ${ELAPSED}s"
              break
            fi
            sleep 5
            ELAPSED=$((ELAPSED + 5))
            echo "â³ Waiting for ADB device... ${ELAPSED}s"
          done
          
          if ! adb devices 2>/dev/null | grep -q "emulator-"; then
            echo "âŒ ERROR: No emulator device found by ADB!"
            adb devices -l
            tail -100 $LOGS_DIR/emulator.log || true
            exit 1
          fi
          
          echo "Waiting for boot completion..."
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            BOOT_COMPLETED=$(adb shell getprop sys.boot_completed 2>/dev/null | tr -d '\r\n' || echo "")
            if [ "$BOOT_COMPLETED" = "1" ]; then
              echo "âœ… Emulator booted after ${ELAPSED}s"
              break
            fi
            sleep 5
            ELAPSED=$((ELAPSED + 5))
            BOOT_ANIM=$(adb shell getprop init.svc.bootanim 2>/dev/null | tr -d '\r\n' || echo "unknown")
            echo "â³ Waiting... ${ELAPSED}s (boot_completed=$BOOT_COMPLETED, bootanim=$BOOT_ANIM)"
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "âŒ ERROR: Emulator boot timeout"
            adb devices -l
            tail -100 $LOGS_DIR/emulator.log || true
            exit 1
          fi
          
          echo "Waiting for system stability..."
          sleep 20
          
          echo "=== Final Verification ==="
          adb devices -l
          echo "Android Version: $(adb shell getprop ro.build.version.release)"
          echo "CPU ABI: $(adb shell getprop ro.product.cpu.abi)"
          echo "Device: $(adb shell getprop ro.product.device)"
          echo "âœ… Emulator ready"

      # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
      # â•‘  PHASE 6: ROOT EMULATOR WITH MAGISK                                         â•‘
      # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      - name: Clone rootAVD
        run: |
          echo "=== Setting up rootAVD ==="
          cd /tmp
          git clone https://github.com/newbit1/rootAVD.git
          cd rootAVD
          chmod +x rootAVD.sh
          ls -la
          echo "âœ… rootAVD cloned"

      - name: Root AVD with Magisk
        run: |
          echo "=== Rooting AVD with Magisk ==="
          cd /tmp/rootAVD
          
          RAMDISK_PATH="$ANDROID_HOME/system-images/android-${{ inputs.android_api }}/google_apis_playstore/x86_64/ramdisk.img"
          
          if [ ! -f "$RAMDISK_PATH" ]; then
            echo "Looking for ramdisk..."
            find $ANDROID_HOME/system-images -name "ramdisk.img" 2>/dev/null | head -5
            RAMDISK_PATH=$(find $ANDROID_HOME/system-images -path "*android-${{ inputs.android_api }}*" -name "ramdisk.img" | head -1)
          fi
          
          echo "Ramdisk: $RAMDISK_PATH"
          
          if [ -f "$RAMDISK_PATH" ]; then
            echo "1" | timeout 300 ./rootAVD.sh "$RAMDISK_PATH" || {
              echo "rootAVD completed (may have warnings)"
            }
          else
            echo "âš ï¸ Ramdisk not found - skipping rootAVD"
          fi
          
          echo "âœ… rootAVD execution completed"

      - name: Verify Root and Reboot
        continue-on-error: true
        run: |
          echo "=== Verifying Root ==="
          adb shell pm list packages | grep -i magisk || echo "Magisk package not found yet"
          
          ROOT_TEST=$(adb shell "su -c 'whoami'" 2>&1 || echo "no_root")
          if echo "$ROOT_TEST" | grep -q "root"; then
            echo "âœ… Root access confirmed!"
            echo "ROOT_AVAILABLE=true" >> $GITHUB_ENV
          else
            echo "âš ï¸ Root not yet available (expected on first boot)"
            echo "ROOT_AVAILABLE=pending" >> $GITHUB_ENV
          fi
          
          echo "âœ… Root verification completed"

      # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
      # â•‘  PHASE 7: START FRIDA SERVER                                                â•‘
      # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      - name: Download and Start Frida Server
        run: |
          echo "=== Setting up Frida Server ==="
          
          # Get Frida version
          FRIDA_VERSION=$(frida --version)
          echo "Frida version: $FRIDA_VERSION"
          
          # Download Frida server for Android x86_64
          FRIDA_SERVER_URL="https://github.com/frida/frida/releases/download/${FRIDA_VERSION}/frida-server-${FRIDA_VERSION}-android-x86_64.xz"
          echo "Downloading from: $FRIDA_SERVER_URL"
          
          wget -q "$FRIDA_SERVER_URL" -O /tmp/frida-server.xz || {
            echo "Trying alternative download..."
            FRIDA_VERSION=$(pip show frida-tools | grep Version | cut -d' ' -f2)
            wget -q "https://github.com/frida/frida/releases/download/${FRIDA_VERSION}/frida-server-${FRIDA_VERSION}-android-x86_64.xz" -O /tmp/frida-server.xz
          }
          
          xz -d /tmp/frida-server.xz
          chmod +x /tmp/frida-server
          
          # Push to device
          adb push /tmp/frida-server /data/local/tmp/frida-server
          adb shell chmod 755 /data/local/tmp/frida-server
          
          # Start Frida server
          echo "Starting Frida server..."
          adb shell "su -c '/data/local/tmp/frida-server -D &'" 2>/dev/null || \
          adb shell "/data/local/tmp/frida-server -D &" 2>/dev/null || {
            echo "Starting Frida server without root..."
            adb shell "/data/local/tmp/frida-server &"
          }
          
          sleep 5
          
          # Verify Frida server
          echo "Testing Frida connection..."
          frida-ps -U || echo "Frida-ps check completed"
          
          echo "âœ… Frida server setup completed"

      # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
      # â•‘  PHASE 8: CREATE FASTAPI CONTROLLER SERVER                                  â•‘
      # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      - name: Create Claude Controller API Server
        run: |
          cat > /tmp/claude_controller_server.py << 'SERVERCODE'
          #!/usr/bin/env python3
          """
          Claude Android Frida Controller - GitHub Actions Server
          =========================================================
          This FastAPI server provides the API endpoints that the Colab bridge
          uses to control the Android emulator and Frida.
          """
          
          import os
          import sys
          import json
          import subprocess
          import shutil
          import traceback
          import asyncio
          from datetime import datetime
          from typing import Optional, Dict, Any, List
          from pathlib import Path
          
          from fastapi import FastAPI, HTTPException, UploadFile, File, Form, Query
          from fastapi.middleware.cors import CORSMiddleware
          from fastapi.responses import FileResponse, JSONResponse
          from pydantic import BaseModel
          import psutil
          
          # ==================== CONFIGURATION ====================
          
          WORK_DIR = os.environ.get("WORK_DIR", "/tmp/android_security")
          APK_DIR = os.environ.get("APK_DIR", "/tmp/android_security/apks")
          OUTPUT_DIR = os.environ.get("OUTPUT_DIR", "/tmp/android_security/output")
          SCRIPTS_DIR = os.environ.get("SCRIPTS_DIR", "/tmp/android_security/scripts")
          LOGS_DIR = os.environ.get("LOGS_DIR", "/tmp/android_security/logs")
          
          # Ensure directories exist
          for d in [WORK_DIR, APK_DIR, OUTPUT_DIR, SCRIPTS_DIR, LOGS_DIR]:
              os.makedirs(d, exist_ok=True)
          
          # Track current APK
          current_apk_path: Optional[str] = None
          
          # ==================== PYDANTIC MODELS ====================
          
          class CommandRequest(BaseModel):
              command: str
              timeout: Optional[int] = 300
          
          class DownloadRequest(BaseModel):
              url: str
              filename: Optional[str] = None
          
          class FridaScriptRequest(BaseModel):
              script: str
              package_name: str
              spawn: bool = True
          
          # ==================== FASTAPI APP ====================
          
          app = FastAPI(
              title="Claude Android Frida Controller",
              description="GitHub Actions server for Android security testing",
              version="4.0.0"
          )
          
          app.add_middleware(
              CORSMiddleware,
              allow_origins=["*"],
              allow_credentials=True,
              allow_methods=["*"],
              allow_headers=["*"],
          )
          
          # ==================== HELPER FUNCTIONS ====================
          
          def run_command(cmd: str, timeout: int = 300) -> Dict[str, Any]:
              """Run a shell command and return result"""
              try:
                  result = subprocess.run(
                      cmd, shell=True, capture_output=True, text=True, timeout=timeout
                  )
                  return {
                      "success": result.returncode == 0,
                      "returncode": result.returncode,
                      "stdout": result.stdout,
                      "stderr": result.stderr
                  }
              except subprocess.TimeoutExpired:
                  return {"success": False, "error": f"Command timed out after {timeout}s"}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          def run_adb(cmd: str, timeout: int = 120) -> Dict[str, Any]:
              """Run an ADB command"""
              return run_command(f"adb {cmd}", timeout)
          
          def run_frida(args: str, timeout: int = 60) -> Dict[str, Any]:
              """Run a Frida command"""
              return run_command(f"frida {args}", timeout)
          
          # ==================== ROOT ENDPOINTS ====================
          
          @app.get("/")
          def root():
              return {
                  "status": "online",
                  "service": "Claude Android Frida Controller",
                  "version": "4.0.0",
                  "location": "GitHub Actions",
                  "endpoints": {
                      "health": "/health",
                      "tools": "/tools",
                      "apk": ["/apk/list", "/apk/info", "/apk/install", "/apk/patch", "/apk/decompile", "/apk/launch"],
                      "frida": ["/frida/processes", "/frida/apps", "/frida/spawn", "/frida/attach", "/frida/script", "/frida/scripts"],
                      "bypass": ["/frida/root-bypass", "/frida/ssl-bypass", "/frida/emulator-bypass", "/frida/all-bypass"],
                      "adb": ["/adb/shell", "/adb/pull", "/adb/push"]
                  }
              }
          
          @app.get("/health")
          def health():
              """Comprehensive health check"""
              # Check emulator
              emu_result = run_adb("devices")
              emulator_online = "emulator-" in emu_result.get("stdout", "")
              
              # Check boot status
              boot_result = run_adb("shell getprop sys.boot_completed")
              boot_completed = boot_result.get("stdout", "").strip() == "1"
              
              # Check Frida
              frida_result = run_command("frida-ps -U 2>/dev/null | head -5")
              frida_running = frida_result.get("success", False)
              
              # Check root
              root_result = run_adb("shell su -c 'whoami' 2>/dev/null")
              root_available = "root" in root_result.get("stdout", "")
              
              return {
                  "status": "healthy" if emulator_online and boot_completed else "degraded",
                  "emulator": "online" if emulator_online else "offline",
                  "boot_completed": boot_completed,
                  "frida_server": "running" if frida_running else "not_running",
                  "root_available": root_available,
                  "cpu_percent": psutil.cpu_percent(),
                  "memory_percent": psutil.virtual_memory().percent,
                  "disk_free_gb": round(psutil.disk_usage('/').free / (1024**3), 2),
                  "timestamp": datetime.now().isoformat()
              }
          
          @app.get("/tools")
          def tools():
              """List available tools and versions"""
              tools_info = {}
              
              # Check each tool
              checks = {
                  "frida": "frida --version",
                  "objection": "objection version 2>&1 | head -1",
                  "apktool": "apktool --version 2>&1 | head -1",
                  "jadx": "jadx --version 2>&1 | head -1",
                  "adb": "adb version 2>&1 | head -1",
                  "aapt": "aapt version 2>&1 | head -1"
              }
              
              for tool, cmd in checks.items():
                  result = run_command(cmd, timeout=10)
                  if result.get("success"):
                      tools_info[tool] = result.get("stdout", "").strip().split('\n')[0]
                  else:
                      tools_info[tool] = "not available"
              
              return {"success": True, "tools": tools_info}
          
          # ==================== APK ENDPOINTS ====================
          
          @app.post("/upload")
          async def upload_apk(file: UploadFile = File(...)):
              """Upload an APK file"""
              global current_apk_path
              
              filepath = os.path.join(APK_DIR, file.filename)
              with open(filepath, "wb") as f:
                  content = await file.read()
                  f.write(content)
              
              current_apk_path = filepath
              size_mb = os.path.getsize(filepath) / (1024 * 1024)
              
              return {
                  "success": True,
                  "filepath": filepath,
                  "filename": file.filename,
                  "size_mb": round(size_mb, 2)
              }
          
          @app.post("/download")
          def download_apk(request: DownloadRequest):
              """Download APK from URL"""
              global current_apk_path
              
              filename = request.filename or request.url.split('/')[-1].split('?')[0]
              if not filename.endswith('.apk'):
                  filename += '.apk'
              
              filepath = os.path.join(APK_DIR, filename)
              
              result = run_command(f'wget -q -O "{filepath}" "{request.url}"', timeout=600)
              
              if os.path.exists(filepath) and os.path.getsize(filepath) > 0:
                  current_apk_path = filepath
                  return {
                      "success": True,
                      "filepath": filepath,
                      "size_mb": round(os.path.getsize(filepath) / (1024*1024), 2)
                  }
              else:
                  return {"success": False, "error": "Download failed", "details": result}
          
          @app.get("/apk/list")
          def list_apks():
              """List available APKs"""
              apks = []
              if os.path.exists(APK_DIR):
                  for f in os.listdir(APK_DIR):
                      if f.endswith('.apk'):
                          path = os.path.join(APK_DIR, f)
                          apks.append({
                              "name": f,
                              "path": path,
                              "size_mb": round(os.path.getsize(path) / (1024*1024), 2)
                          })
              return {"success": True, "apks": apks, "current": current_apk_path}
          
          @app.get("/apk/info")
          def apk_info(path: str = None):
              """Get APK information using aapt and androguard"""
              apk_path = path or current_apk_path
              if not apk_path or not os.path.exists(apk_path):
                  return {"success": False, "error": "No APK specified or found"}
              
              info = {"path": apk_path}
              
              # Use aapt for basic info
              aapt_result = run_command(f'aapt dump badging "{apk_path}" 2>/dev/null | head -20')
              if aapt_result.get("success"):
                  output = aapt_result.get("stdout", "")
                  # Parse package name
                  for line in output.split('\n'):
                      if line.startswith("package:"):
                          parts = line.split("'")
                          if len(parts) >= 2:
                              info["package"] = parts[1]
                          if "versionName=" in line:
                              for p in line.split():
                                  if p.startswith("versionName="):
                                      info["version"] = p.split("'")[1]
              
              # Get permissions
              perm_result = run_command(f'aapt dump permissions "{apk_path}" 2>/dev/null')
              if perm_result.get("success"):
                  perms = []
                  for line in perm_result.get("stdout", "").split('\n'):
                      if "uses-permission:" in line:
                          perm = line.split("'")[1] if "'" in line else line.split()[-1]
                          perms.append(perm)
                  info["permissions"] = perms
              
              info["success"] = True
              return info
          
          @app.post("/apk/install")
          def install_apk(path: str = None):
              """Install APK on emulator"""
              apk_path = path or current_apk_path
              if not apk_path or not os.path.exists(apk_path):
                  return {"success": False, "error": "No APK specified or found"}
              
              result = run_adb(f'install -r -g "{apk_path}"', timeout=180)
              return {
                  "success": "Success" in result.get("stdout", "") or result.get("success", False),
                  "path": apk_path,
                  "output": result.get("stdout", "") + result.get("stderr", "")
              }
          
          @app.post("/apk/patch")
          def patch_apk(path: str = None):
              """Patch APK with Frida gadget using objection"""
              apk_path = path or current_apk_path
              if not apk_path or not os.path.exists(apk_path):
                  return {"success": False, "error": "No APK specified or found"}
              
              result = run_command(f'objection patchapk -s "{apk_path}"', timeout=600)
              
              # Find patched APK
              patched_path = apk_path.replace('.apk', '.objection.apk')
              if os.path.exists(patched_path):
                  return {"success": True, "original": apk_path, "patched": patched_path}
              
              return {"success": False, "error": "Patching failed", "details": result}
          
          @app.post("/apk/decompile")
          def decompile_apk(path: str = None):
              """Decompile APK using apktool"""
              apk_path = path or current_apk_path
              if not apk_path or not os.path.exists(apk_path):
                  return {"success": False, "error": "No APK specified or found"}
              
              output_dir = os.path.join(OUTPUT_DIR, Path(apk_path).stem + "_decompiled")
              
              result = run_command(f'apktool d -f -o "{output_dir}" "{apk_path}"', timeout=300)
              
              if os.path.exists(output_dir):
                  return {"success": True, "apk": apk_path, "output_dir": output_dir}
              
              return {"success": False, "error": "Decompilation failed", "details": result}
          
          @app.post("/apk/launch")
          def launch_app(package: str):
              """Launch app on emulator"""
              # Get launcher activity
              result = run_adb(f'shell cmd package resolve-activity --brief {package} | tail -1')
              activity = result.get("stdout", "").strip()
              
              if activity and "/" in activity:
                  launch_result = run_adb(f'shell am start -n {activity}')
              else:
                  # Try monkey
                  launch_result = run_adb(f'shell monkey -p {package} -c android.intent.category.LAUNCHER 1')
              
              return {
                  "success": launch_result.get("success", False),
                  "package": package,
                  "activity": activity,
                  "output": launch_result.get("stdout", "") + launch_result.get("stderr", "")
              }
          
          # ==================== FRIDA ENDPOINTS ====================
          
          @app.get("/frida/processes")
          def frida_processes():
              """List running processes"""
              result = run_command("frida-ps -U", timeout=30)
              if result.get("success"):
                  lines = result.get("stdout", "").strip().split('\n')
                  processes = []
                  for line in lines[1:]:  # Skip header
                      parts = line.split()
                      if len(parts) >= 2:
                          processes.append({"pid": parts[0], "name": ' '.join(parts[1:])})
                  return {"success": True, "processes": processes}
              return {"success": False, "error": result.get("error", "Failed to get processes")}
          
          @app.get("/frida/apps")
          def frida_apps():
              """List installed apps"""
              result = run_command("frida-ps -Ua", timeout=30)
              if result.get("success"):
                  lines = result.get("stdout", "").strip().split('\n')
                  apps = []
                  for line in lines[1:]:  # Skip header
                      parts = line.split()
                      if len(parts) >= 3:
                          apps.append({
                              "pid": parts[0],
                              "name": parts[1],
                              "identifier": ' '.join(parts[2:])
                          })
                  return {"success": True, "apps": apps}
              return {"success": False, "error": result.get("error", "Failed to get apps")}
          
          @app.post("/frida/spawn")
          def frida_spawn(package_name: str, script_path: str = None):
              """Spawn app with Frida"""
              cmd = f'frida -U -f {package_name}'
              if script_path and os.path.exists(script_path):
                  cmd += f' -l "{script_path}"'
              cmd += ' --no-pause -q &'
              
              result = run_command(cmd, timeout=30)
              return {
                  "success": True,
                  "package": package_name,
                  "script": script_path,
                  "output": result.get("stdout", "") + result.get("stderr", "")
              }
          
          @app.post("/frida/attach")
          def frida_attach(package_name: str):
              """Attach Frida to running app"""
              result = run_command(f'frida -U {package_name} -q &', timeout=30)
              return {
                  "success": True,
                  "package": package_name,
                  "output": result.get("stdout", "") + result.get("stderr", "")
              }
          
          @app.post("/frida/script")
          def frida_script(request: FridaScriptRequest):
              """Run custom Frida script"""
              # Save script to temp file
              script_path = os.path.join(SCRIPTS_DIR, f"custom_{datetime.now().strftime('%Y%m%d_%H%M%S')}.js")
              with open(script_path, 'w') as f:
                  f.write(request.script)
              
              if request.spawn:
                  cmd = f'timeout 60 frida -U -f {request.package_name} -l "{script_path}" --no-pause 2>&1 || true'
              else:
                  cmd = f'timeout 60 frida -U {request.package_name} -l "{script_path}" 2>&1 || true'
              
              result = run_command(cmd, timeout=120)
              
              return {
                  "success": True,
                  "package": request.package_name,
                  "spawn": request.spawn,
                  "script_path": script_path,
                  "output": result.get("stdout", "") + result.get("stderr", "")
              }
          
          @app.get("/frida/scripts")
          def frida_scripts():
              """List available Frida scripts"""
              scripts = []
              if os.path.exists(SCRIPTS_DIR):
                  for f in os.listdir(SCRIPTS_DIR):
                      if f.endswith('.js'):
                          scripts.append({
                              "name": f,
                              "path": os.path.join(SCRIPTS_DIR, f)
                          })
              return {"success": True, "scripts": scripts}
          
          # ==================== BYPASS ENDPOINTS ====================
          
          def run_bypass(package_name: str, script_name: str, spawn: bool = True) -> Dict[str, Any]:
              """Helper to run bypass scripts"""
              script_path = os.path.join(SCRIPTS_DIR, script_name)
              if not os.path.exists(script_path):
                  return {"success": False, "error": f"Script not found: {script_path}"}
              
              if spawn:
                  cmd = f'frida -U -f {package_name} -l "{script_path}" --no-pause &'
              else:
                  cmd = f'frida -U {package_name} -l "{script_path}" &'
              
              result = run_command(cmd, timeout=30)
              return {
                  "success": True,
                  "package": package_name,
                  "bypass": script_name,
                  "spawn": spawn,
                  "output": result.get("stdout", "") + result.get("stderr", "")
              }
          
          @app.post("/frida/root-bypass")
          def root_bypass(package_name: str, spawn: bool = True):
              """Apply root detection bypass"""
              return run_bypass(package_name, "root_bypass.js", spawn)
          
          @app.post("/frida/ssl-bypass")
          def ssl_bypass(package_name: str, spawn: bool = True):
              """Apply SSL pinning bypass"""
              return run_bypass(package_name, "ssl_bypass.js", spawn)
          
          @app.post("/frida/emulator-bypass")
          def emulator_bypass(package_name: str, spawn: bool = True):
              """Apply emulator detection bypass"""
              return run_bypass(package_name, "emulator_bypass.js", spawn)
          
          @app.post("/frida/frida-bypass")
          def frida_detection_bypass(package_name: str, spawn: bool = True):
              """Apply Frida detection bypass"""
              return run_bypass(package_name, "frida_bypass.js", spawn)
          
          @app.post("/frida/all-bypass")
          def all_bypass(package_name: str, spawn: bool = True):
              """Apply ALL bypasses"""
              return run_bypass(package_name, "all_bypass.js", spawn)
          
          # ==================== ADB ENDPOINTS ====================
          
          @app.post("/adb/shell")
          def adb_shell(request: CommandRequest):
              """Execute ADB shell command"""
              result = run_adb(f'shell {request.command}', timeout=request.timeout)
              return result
          
          @app.post("/adb/pull")
          def adb_pull(remote: str, local: str = None):
              """Pull file from emulator"""
              if not local:
                  local = os.path.join(OUTPUT_DIR, os.path.basename(remote))
              
              result = run_adb(f'pull "{remote}" "{local}"')
              
              if os.path.exists(local):
                  return {"success": True, "remote": remote, "local": local}
              return {"success": False, "error": "Pull failed", "details": result}
          
          @app.post("/adb/push")
          def adb_push(local: str, remote: str):
              """Push file to emulator"""
              if not os.path.exists(local):
                  return {"success": False, "error": f"Local file not found: {local}"}
              
              result = run_adb(f'push "{local}" "{remote}"')
              return {
                  "success": result.get("success", False),
                  "local": local,
                  "remote": remote,
                  "output": result.get("stdout", "") + result.get("stderr", "")
              }
          
          # ==================== MAIN ====================
          
          if __name__ == "__main__":
              import uvicorn
              port = int(os.environ.get("SERVER_PORT", 8000))
              print(f"Starting Claude Android Frida Controller on port {port}")
              uvicorn.run(app, host="0.0.0.0", port=port, log_level="info")
          SERVERCODE
          
          chmod +x /tmp/claude_controller_server.py
          echo "âœ… Claude Controller API server created"

      # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
      # â•‘  PHASE 9: SETUP NGROK AND START SERVER                                      â•‘
      # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      - name: Setup ngrok
        run: |
          echo "=== Installing ngrok ==="
          curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
          echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
          sudo apt-get update -qq && sudo apt-get install -y -qq ngrok
          
          # Configure ngrok with auth token from secrets
          if [ -n "${{ secrets.NGROK_AUTH_TOKEN }}" ]; then
            ngrok config add-authtoken ${{ secrets.NGROK_AUTH_TOKEN }}
            echo "âœ… ngrok configured with auth token"
          else
            echo "âš ï¸ NGROK_AUTH_TOKEN secret not set - ngrok may have limitations"
          fi

      - name: Start API Server and ngrok Tunnel
        run: |
          echo "=== Starting Claude Controller API Server ==="
          
          # Start the FastAPI server
          cd /tmp
          nohup python3 claude_controller_server.py > $LOGS_DIR/server.log 2>&1 &
          SERVER_PID=$!
          echo "Server PID: $SERVER_PID"
          echo "SERVER_PID=$SERVER_PID" >> $GITHUB_ENV
          
          # Wait for server to start
          sleep 5
          
          # Verify server is running
          curl -s http://localhost:${{ inputs.server_port }}/health || {
            echo "Server may still be starting..."
            sleep 5
            curl -s http://localhost:${{ inputs.server_port }}/health
          }
          
          echo "=== Starting ngrok Tunnel ==="
          nohup ngrok http ${{ inputs.server_port }} --log=stdout > $LOGS_DIR/ngrok.log 2>&1 &
          NGROK_PID=$!
          echo "ngrok PID: $NGROK_PID"
          echo "NGROK_PID=$NGROK_PID" >> $GITHUB_ENV
          
          # Wait for ngrok to establish tunnel
          sleep 10
          
          # Get public URL
          NGROK_URL=""
          for i in {1..10}; do
            NGROK_URL=$(curl -s http://localhost:4040/api/tunnels 2>/dev/null | jq -r '.tunnels[0].public_url' 2>/dev/null || echo "")
            if [ -n "$NGROK_URL" ] && [ "$NGROK_URL" != "null" ]; then
              break
            fi
            echo "Waiting for ngrok tunnel... attempt $i"
            sleep 3
          done
          
          if [ -z "$NGROK_URL" ] || [ "$NGROK_URL" == "null" ]; then
            echo "âš ï¸ Could not get ngrok URL automatically"
            echo "Check ngrok dashboard or logs"
            cat $LOGS_DIR/ngrok.log | tail -50
          else
            echo "NGROK_URL=$NGROK_URL" >> $GITHUB_ENV
          fi
          
          echo "âœ… Server and tunnel started"

      - name: Display Connection Information
        run: |
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘  ðŸŽ‰ CLAUDE ANDROID FRIDA CONTROLLER IS READY!                              â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘                                                                            â•‘"
          
          if [ -n "$NGROK_URL" ]; then
            echo "â•‘  ðŸ“¡ PUBLIC URL: $NGROK_URL"
            echo "â•‘                                                                            â•‘"
            echo "â•‘  ðŸ“‹ Use this URL to connect from Google Colab:                            â•‘"
            echo "â•‘     POST $NGROK_URL/workflow/connect                             â•‘"
            echo "â•‘     Body: {\"url\": \"$NGROK_URL\"}                      â•‘"
          else
            echo "â•‘  âš ï¸  ngrok URL not available - check logs                                 â•‘"
            echo "â•‘  Try: curl http://localhost:4040/api/tunnels                              â•‘"
          fi
          
          echo "â•‘                                                                            â•‘"
          echo "â•‘  ðŸ“– API Documentation: ${NGROK_URL:-http://localhost:${{ inputs.server_port }}}/docs                              â•‘"
          echo "â•‘                                                                            â•‘"
          echo "â•‘  ðŸ”§ Available Endpoints:                                                   â•‘"
          echo "â•‘     GET  /health          - System health check                            â•‘"
          echo "â•‘     GET  /tools           - Available tools                                â•‘"
          echo "â•‘     POST /apk/install     - Install APK                                    â•‘"
          echo "â•‘     POST /frida/all-bypass - Launch with all bypasses                      â•‘"
          echo "â•‘     POST /adb/shell       - Execute ADB command                            â•‘"
          echo "â•‘                                                                            â•‘"
          echo "â•‘  â±ï¸  Session Duration: ${{ inputs.session_duration }} minutes                                     â•‘"
          echo "â•‘  ðŸ“± Android API: ${{ inputs.android_api }}                                                       â•‘"
          echo "â•‘  ðŸ”“ Root Status: ${ROOT_AVAILABLE:-unknown}                                             â•‘"
          echo "â•‘                                                                            â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          # Also display in job summary
          echo "## ðŸ¤– Claude Android Frida Controller" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Connection Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Public URL**: \`${NGROK_URL:-Not available}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **API Docs**: ${NGROK_URL:-http://localhost:${{ inputs.server_port }}}/docs" >> $GITHUB_STEP_SUMMARY
          echo "- **Android API**: ${{ inputs.android_api }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Session Duration**: ${{ inputs.session_duration }} minutes" >> $GITHUB_STEP_SUMMARY
          echo "- **Root Status**: ${ROOT_AVAILABLE:-unknown}" >> $GITHUB_STEP_SUMMARY

      # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
      # â•‘  PHASE 10: KEEP SESSION ALIVE                                               â•‘
      # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      - name: Keep Session Alive
        run: |
          echo "=== Session Active ==="
          echo "Session will run for ${{ inputs.session_duration }} minutes"
          echo "Press Ctrl+C in the workflow to stop early"
          echo ""
          
          SESSION_SECONDS=$(( ${{ inputs.session_duration }} * 60 ))
          START_TIME=$(date +%s)
          
          while true; do
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))
            REMAINING=$((SESSION_SECONDS - ELAPSED))
            
            if [ $ELAPSED -ge $SESSION_SECONDS ]; then
              echo ""
              echo "â° Session time expired"
              break
            fi
            
            # Status update every 60 seconds
            REMAINING_MIN=$((REMAINING / 60))
            echo "[$(date '+%H:%M:%S')] Session active | ${REMAINING_MIN}m remaining | Emulator: $(adb devices | grep -c emulator || echo 0) | URL: ${NGROK_URL:-local}"
            
            # Health check
            curl -s http://localhost:${{ inputs.server_port }}/health > /dev/null 2>&1 || {
              echo "âš ï¸ Server health check failed - restarting..."
              cd /tmp && python3 claude_controller_server.py &
              sleep 5
            }
            
            sleep 60
          done
          
          echo "=== Session Ended ==="

      - name: Cleanup
        if: always()
        run: |
          echo "=== Cleaning up ==="
          
          # Kill processes
          kill $SERVER_PID 2>/dev/null || true
          kill $NGROK_PID 2>/dev/null || true
          kill $EMULATOR_PID 2>/dev/null || true
          
          # Save logs
          echo "=== Server Log ===" 
          cat $LOGS_DIR/server.log 2>/dev/null | tail -100 || true
          
          echo "=== ngrok Log ==="
          cat $LOGS_DIR/ngrok.log 2>/dev/null | tail -50 || true
          
          echo "âœ… Cleanup completed"
