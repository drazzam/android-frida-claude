name: Android Security Testing - Complete Toolkit v3 (Rooted)

on:
  workflow_dispatch:
    inputs:
      session_duration:
        description: 'Session duration in minutes'
        required: true
        default: '45'
        type: choice
        options:
          - '15'
          - '30'
          - '45'
          - '60'
      android_api:
        description: 'Android API level'
        required: true
        default: '31'
        type: choice
        options:
          - '29'
          - '30'
          - '31'
          - '33'
      server_port:
        description: 'Server port'
        required: true
        default: '8000'
      enable_advanced_tools:
        description: 'Install advanced tools (radare2, APKiD)'
        required: true
        default: true
        type: boolean

env:
  ANDROID_AVD_HOME: /home/runner/.android/avd
  ANDROID_SDK_ROOT: /usr/local/lib/android/sdk
  ANDROID_HOME: /usr/local/lib/android/sdk
  JAVA_HOME: /usr/lib/jvm/temurin-17-jdk-amd64
  ANDROID_API: ${{ inputs.android_api }}
  SERVER_PORT: ${{ inputs.server_port }}

jobs:
  android-security-session:
    runs-on: ubuntu-latest
    timeout-minutes: 65

    steps:
      # ============================================
      # PHASE 1: SYSTEM SETUP
      # ============================================
      
      - name: System Information
        run: |
          echo "============================================"
          echo "ðŸš€ ANDROID SECURITY TESTING v3.0 (ROOTED)"
          echo "============================================"
          echo "Runner: $(uname -a)"
          echo "CPU: $(nproc) cores"
          echo "RAM: $(free -h | grep Mem | awk '{print $2}')"
          echo "Disk: $(df -h / | tail -1 | awk '{print $4}') available"
          echo "Android API: ${{ inputs.android_api }}"
          echo "Session Duration: ${{ inputs.session_duration }} minutes"
          echo "============================================"

      - name: Enable KVM Acceleration
        run: |
          echo 'KERNEL=="kvm", GROUP="kvm", MODE="0666", OPTIONS+="static_node=kvm"' | sudo tee /etc/udev/rules.d/99-kvm4all.rules
          sudo udevadm control --reload-rules
          sudo udevadm trigger --name-match=kvm
          ls -la /dev/kvm
          echo "âœ… KVM enabled"

      - name: Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install System Dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq \
            wget curl unzip zip git jq \
            build-essential cmake pkg-config \
            libssl-dev libffi-dev libxml2-dev libxslt1-dev \
            zlib1g-dev libjpeg-dev libpng-dev \
            android-tools-adb android-tools-fastboot \
            aapt apksigner zipalign \
            openjdk-17-jdk graphviz \
            libc6-i386 lib32stdc++6 lib32z1 \
            qemu-kvm libvirt-daemon-system \
            xz-utils p7zip-full
          echo "âœ… System dependencies installed"

      # ============================================
      # PHASE 2: ANDROID SDK SETUP
      # ============================================

      - name: Configure Android SDK Paths
        run: |
          echo "$ANDROID_HOME/cmdline-tools/latest/bin" >> $GITHUB_PATH
          echo "$ANDROID_HOME/platform-tools" >> $GITHUB_PATH
          echo "$ANDROID_HOME/emulator" >> $GITHUB_PATH
          echo "$ANDROID_HOME/build-tools/34.0.0" >> $GITHUB_PATH
          echo "âœ… Android SDK paths configured"

      - name: Install Android SDK Components
        run: |
          SDKMANAGER="$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager"
          
          echo "=== Accepting Licenses ==="
          yes | $SDKMANAGER --licenses > /dev/null 2>&1 || true
          
          echo "=== Installing Build Tools ==="
          $SDKMANAGER --install "build-tools;34.0.0" "build-tools;33.0.2" "build-tools;30.0.3"
          
          echo "=== Installing Platform Tools ==="
          $SDKMANAGER --install "platform-tools"
          
          echo "=== Installing System Image (PlayStore for rootAVD) ==="
          # CRITICAL: Use google_apis_playstore for rootAVD compatibility
          $SDKMANAGER --install "system-images;android-${{ inputs.android_api }};google_apis_playstore;x86_64"
          
          echo "=== Verifying Installation ==="
          $SDKMANAGER --list_installed | grep -E "system-images|build-tools|platform-tools" || true
          adb version
          echo "âœ… Android SDK components installed"

      # ============================================
      # PHASE 3: SECURITY TOOLS INSTALLATION
      # ============================================

      - name: Install APKTool
        run: |
          APKTOOL_VERSION="2.9.3"
          sudo wget -q "https://github.com/iBotPeaches/Apktool/releases/download/v${APKTOOL_VERSION}/apktool_${APKTOOL_VERSION}.jar" -O /usr/local/bin/apktool.jar
          sudo wget -q "https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/linux/apktool" -O /usr/local/bin/apktool
          sudo chmod +x /usr/local/bin/apktool
          apktool --version
          echo "âœ… APKTool installed"

      - name: Install JADX
        run: |
          JADX_VERSION="1.5.0"
          wget -q "https://github.com/skylot/jadx/releases/download/v${JADX_VERSION}/jadx-${JADX_VERSION}.zip" -O jadx.zip
          sudo unzip -q jadx.zip -d /opt/jadx
          sudo ln -sf /opt/jadx/bin/jadx /usr/local/bin/jadx
          sudo ln -sf /opt/jadx/bin/jadx-gui /usr/local/bin/jadx-gui
          jadx --version
          echo "âœ… JADX installed"

      - name: Install Python Security Tools
        run: |
          pip install --upgrade pip
          pip install frida-tools objection androguard lief --break-system-packages
          
          # Install uber-apk-signer
          wget -q "https://github.com/nicebyte/uber-apk-signer/releases/latest/download/uber-apk-signer.jar" -O /tmp/uber-apk-signer.jar 2>/dev/null || \
          wget -q "https://github.com/nicebyte/uber-apk-signer/releases/download/0.0.1/uber-apk-signer-0.0.1.jar" -O /tmp/uber-apk-signer.jar || true
          
          echo "Frida version: $(frida --version)"
          echo "Objection version: $(objection version 2>&1 | head -1)"
          echo "âœ… Python security tools installed"

      - name: Install Dex2Jar
        continue-on-error: true
        run: |
          DEX2JAR_VERSION="2.4"
          wget -q "https://github.com/pxb1988/dex2jar/releases/download/v${DEX2JAR_VERSION}/dex-tools-v${DEX2JAR_VERSION}.zip" -O dex2jar.zip || \
          wget -q "https://github.com/pxb1988/dex2jar/releases/download/2.1/dex-tools-2.1.zip" -O dex2jar.zip
          sudo unzip -q dex2jar.zip -d /opt/ || true
          sudo chmod +x /opt/dex-tools-*/d2j-*.sh 2>/dev/null || sudo chmod +x /opt/dex2jar-*/d2j-*.sh 2>/dev/null || true
          echo "âœ… Dex2Jar installed"

      - name: Install Smali/Baksmali
        continue-on-error: true
        run: |
          SMALI_VERSION="3.0.5"
          wget -q "https://github.com/google/smali/releases/download/v${SMALI_VERSION}/smali-${SMALI_VERSION}.jar" -O /tmp/smali.jar || \
          wget -q "https://bitbucket.org/JesusFreke/smali/downloads/smali-2.5.2.jar" -O /tmp/smali.jar || true
          
          wget -q "https://github.com/google/smali/releases/download/v${SMALI_VERSION}/baksmali-${SMALI_VERSION}.jar" -O /tmp/baksmali.jar || \
          wget -q "https://bitbucket.org/JesusFreke/smali/downloads/baksmali-2.5.2.jar" -O /tmp/baksmali.jar || true
          
          if [ -f /tmp/smali.jar ]; then
            echo '#!/bin/bash' | sudo tee /usr/local/bin/smali
            echo 'java -jar /tmp/smali.jar "$@"' | sudo tee -a /usr/local/bin/smali
            sudo chmod +x /usr/local/bin/smali
          fi
          
          if [ -f /tmp/baksmali.jar ]; then
            echo '#!/bin/bash' | sudo tee /usr/local/bin/baksmali
            echo 'java -jar /tmp/baksmali.jar "$@"' | sudo tee -a /usr/local/bin/baksmali
            sudo chmod +x /usr/local/bin/baksmali
          fi
          echo "âœ… Smali/Baksmali installed"

      - name: Install CFR Decompiler
        continue-on-error: true
        run: |
          CFR_VERSION="0.152"
          wget -q "https://github.com/leibnitz27/cfr/releases/download/${CFR_VERSION}/cfr-${CFR_VERSION}.jar" -O /tmp/cfr.jar || true
          if [ -f /tmp/cfr.jar ]; then
            echo '#!/bin/bash' | sudo tee /usr/local/bin/cfr
            echo 'java -jar /tmp/cfr.jar "$@"' | sudo tee -a /usr/local/bin/cfr
            sudo chmod +x /usr/local/bin/cfr
          fi
          echo "âœ… CFR installed"

      - name: Install Advanced Tools
        if: ${{ inputs.enable_advanced_tools }}
        continue-on-error: true
        run: |
          # Radare2
          sudo apt-get install -y radare2 || {
            git clone --depth=1 https://github.com/radareorg/radare2.git /tmp/radare2
            cd /tmp/radare2 && sys/install.sh
          }
          
          # APKiD
          pip install apkid --break-system-packages || true
          
          # Quark Engine
          pip install quark-engine --break-system-packages || true
          
          echo "âœ… Advanced tools installed"

      # ============================================
      # PHASE 4: CREATE AND START EMULATOR
      # ============================================

      - name: Create Android Virtual Device
        run: |
          AVDMANAGER="$ANDROID_HOME/cmdline-tools/latest/bin/avdmanager"
          
          echo "=== Creating AVD with PlayStore image ==="
          echo "no" | $AVDMANAGER create avd \
            -n security_avd \
            -k "system-images;android-${{ inputs.android_api }};google_apis_playstore;x86_64" \
            -d "pixel_4" \
            --force
          
          echo "=== AVD Created ==="
          $AVDMANAGER list avd
          echo "âœ… AVD created"

      - name: Start Android Emulator
        run: |
          echo "=== Starting Emulator ==="
          
          # Start emulator with writable-system for rootAVD
          nohup $ANDROID_HOME/emulator/emulator \
            -avd security_avd \
            -writable-system \
            -no-window \
            -no-audio \
            -no-boot-anim \
            -gpu swiftshader_indirect \
            -no-snapshot-save \
            -memory 4096 \
            -cores 2 \
            -partition-size 8192 \
            -qemu -machine q35 &
          
          EMULATOR_PID=$!
          echo "Emulator PID: $EMULATOR_PID"
          echo "EMULATOR_PID=$EMULATOR_PID" >> $GITHUB_ENV
          echo "âœ… Emulator starting..."

      - name: Wait for Emulator Boot
        run: |
          echo "=== Waiting for Emulator ==="
          TIMEOUT=240
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            BOOT_COMPLETED=$(adb wait-for-device shell getprop sys.boot_completed 2>/dev/null | tr -d '\r\n' || echo "")
            if [ "$BOOT_COMPLETED" = "1" ]; then
              echo "âœ… Emulator booted after ${ELAPSED}s"
              break
            fi
            sleep 5
            ELAPSED=$((ELAPSED + 5))
            echo "â³ Waiting... ${ELAPSED}s (boot_completed=$BOOT_COMPLETED)"
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "âŒ ERROR: Emulator boot timeout"
            adb devices
            exit 1
          fi
          
          # Additional stability wait
          sleep 15
          
          # Verify ADB connection
          adb devices
          adb shell getprop ro.build.version.release
          adb shell getprop ro.product.cpu.abi
          echo "âœ… Emulator ready"

      # ============================================
      # PHASE 5: ROOT EMULATOR WITH MAGISK
      # ============================================

      - name: Clone rootAVD
        run: |
          echo "=== Setting up rootAVD ==="
          cd /tmp
          git clone https://github.com/newbit1/rootAVD.git
          cd rootAVD
          chmod +x rootAVD.sh
          ls -la
          echo "âœ… rootAVD cloned"

      - name: Root AVD with Magisk
        run: |
          echo "=== Rooting AVD with Magisk ==="
          cd /tmp/rootAVD
          
          # Find ramdisk path
          RAMDISK_PATH="$ANDROID_HOME/system-images/android-${{ inputs.android_api }}/google_apis_playstore/x86_64/ramdisk.img"
          
          if [ ! -f "$RAMDISK_PATH" ]; then
            echo "Looking for ramdisk..."
            find $ANDROID_HOME/system-images -name "ramdisk.img" 2>/dev/null | head -5
            # Try alternative path
            RAMDISK_PATH=$(find $ANDROID_HOME/system-images -path "*android-${{ inputs.android_api }}*" -name "ramdisk.img" | head -1)
          fi
          
          echo "Ramdisk: $RAMDISK_PATH"
          
          if [ -f "$RAMDISK_PATH" ]; then
            # Run rootAVD with auto-selection of stable Magisk (option 1)
            echo "1" | timeout 300 ./rootAVD.sh "$RAMDISK_PATH" || {
              echo "rootAVD completed (may have warnings)"
            }
          else
            echo "âš ï¸ Ramdisk not found - skipping rootAVD"
          fi
          
          echo "âœ… rootAVD execution completed"

      - name: Reboot and Verify Root
        run: |
          echo "=== Rebooting Emulator ==="
          
          # Kill and restart emulator for Magisk to take effect
          adb emu kill 2>/dev/null || true
          sleep 5
          
          # Restart emulator
          nohup $ANDROID_HOME/emulator/emulator \
            -avd security_avd \
            -writable-system \
            -no-window \
            -no-audio \
            -no-boot-anim \
            -gpu swiftshader_indirect \
            -no-snapshot-save \
            -memory 4096 \
            -cores 2 &
          
          # Wait for boot
          TIMEOUT=180
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            BOOT_COMPLETED=$(adb wait-for-device shell getprop sys.boot_completed 2>/dev/null | tr -d '\r\n' || echo "")
            if [ "$BOOT_COMPLETED" = "1" ]; then
              echo "âœ… Emulator rebooted after ${ELAPSED}s"
              break
            fi
            sleep 5
            ELAPSED=$((ELAPSED + 5))
            echo "â³ Waiting for reboot... ${ELAPSED}s"
          done
          
          sleep 15
          
          # Test root access
          echo "=== Testing Root Access ==="
          ROOT_TEST=$(adb shell "su -c 'id'" 2>&1 || echo "no_root")
          
          if echo "$ROOT_TEST" | grep -q "uid=0"; then
            echo "âœ… ROOT ACCESS CONFIRMED"
            echo "ROOT_AVAILABLE=true" >> $GITHUB_ENV
          else
            echo "âš ï¸ Root not available via su"
            echo "Trying adb root..."
            adb root 2>/dev/null || true
            sleep 3
            ROOT_TEST2=$(adb shell "id" 2>&1)
            if echo "$ROOT_TEST2" | grep -q "uid=0"; then
              echo "âœ… ROOT via adb root"
              echo "ROOT_AVAILABLE=true" >> $GITHUB_ENV
            else
              echo "âš ï¸ Running without root - using Frida Gadget method"
              echo "ROOT_AVAILABLE=false" >> $GITHUB_ENV
            fi
          fi

      # ============================================
      # PHASE 6: DEPLOY FRIDA
      # ============================================

      - name: Download and Deploy Frida Server
        run: |
          echo "=== Deploying Frida Server ==="
          
          FRIDA_VERSION=$(frida --version)
          echo "Frida version: $FRIDA_VERSION"
          
          # Download frida-server for x86_64
          wget -q "https://github.com/frida/frida/releases/download/${FRIDA_VERSION}/frida-server-${FRIDA_VERSION}-android-x86_64.xz" -O /tmp/frida-server.xz
          xz -d /tmp/frida-server.xz
          
          # Push to device
          adb push /tmp/frida-server /data/local/tmp/frida-server
          adb shell "chmod 755 /data/local/tmp/frida-server"
          
          # Start frida-server
          if [ "$ROOT_AVAILABLE" = "true" ]; then
            echo "Starting frida-server with root..."
            adb shell "su -c 'nohup /data/local/tmp/frida-server -D &'" 2>/dev/null || \
            adb shell "nohup /data/local/tmp/frida-server -D &" || true
          else
            echo "Starting frida-server without root..."
            adb shell "nohup /data/local/tmp/frida-server -D &" || true
          fi
          
          sleep 5
          
          # Verify frida-server
          frida-ps -U 2>/dev/null | head -5 || echo "Frida server check pending..."
          
          echo "FRIDA_VERSION=$FRIDA_VERSION" >> $GITHUB_ENV
          echo "âœ… Frida server deployed"

      - name: Download Frida Gadgets
        run: |
          echo "=== Downloading Frida Gadgets ==="
          
          FRIDA_VERSION=$(frida --version)
          
          # x86_64 gadget
          wget -q "https://github.com/frida/frida/releases/download/${FRIDA_VERSION}/frida-gadget-${FRIDA_VERSION}-android-x86_64.so.xz" -O /tmp/frida-gadget-x86_64.so.xz
          xz -d /tmp/frida-gadget-x86_64.so.xz
          
          # arm64 gadget
          wget -q "https://github.com/frida/frida/releases/download/${FRIDA_VERSION}/frida-gadget-${FRIDA_VERSION}-android-arm64.so.xz" -O /tmp/frida-gadget-arm64.so.xz || true
          xz -d /tmp/frida-gadget-arm64.so.xz 2>/dev/null || true
          
          # arm gadget  
          wget -q "https://github.com/frida/frida/releases/download/${FRIDA_VERSION}/frida-gadget-${FRIDA_VERSION}-android-arm.so.xz" -O /tmp/frida-gadget-arm.so.xz || true
          xz -d /tmp/frida-gadget-arm.so.xz 2>/dev/null || true
          
          ls -la /tmp/frida-gadget-*.so 2>/dev/null || echo "Some gadgets not available"
          echo "âœ… Frida gadgets downloaded"

      # ============================================
      # PHASE 7: CREATE BYPASS SCRIPTS
      # ============================================

      - name: Create Working Directories
        run: |
          mkdir -p /tmp/apks /tmp/decompiled /tmp/patched /tmp/scripts /tmp/logs
          chmod 777 /tmp/apks /tmp/decompiled /tmp/patched /tmp/scripts /tmp/logs
          echo "âœ… Directories created"

      - name: Create Frida Bypass Scripts
        run: |
          # ===== ROOT BYPASS SCRIPT =====
          cat > /tmp/scripts/root_bypass.js << 'SCRIPT_EOF'
          // Universal Root Detection Bypass
          Java.perform(function() {
              console.log("[*] Root Detection Bypass Loading...");
              
              var RootFiles = [
                  "/system/app/Superuser.apk","/sbin/su","/system/bin/su","/system/xbin/su",
                  "/data/local/xbin/su","/data/local/bin/su","/system/sd/xbin/su",
                  "/system/bin/failsafe/su","/data/local/su","/su/bin/su","/su/bin",
                  "/data/adb/magisk","/sbin/.magisk","/data/adb/ksu",
                  "/system/app/SuperSU.apk","/system/app/Superuser/Superuser.apk"
              ];
              
              var RootPackages = [
                  "com.topjohnwu.magisk","com.koushikdutta.superuser","com.noshufou.android.su",
                  "eu.chainfire.supersu","com.yellowes.su","com.kingroot.kinguser"
              ];
              
              // Hook File.exists
              try {
                  var File = Java.use("java.io.File");
                  File.exists.implementation = function() {
                      var path = this.getAbsolutePath();
                      for (var i = 0; i < RootFiles.length; i++) {
                          if (path.indexOf(RootFiles[i]) !== -1) {
                              console.log("[Root] Hidden: " + path);
                              return false;
                          }
                      }
                      return this.exists.call(this);
                  };
              } catch(e) {}
              
              // Hook Runtime.exec
              try {
                  var Runtime = Java.use("java.lang.Runtime");
                  Runtime.exec.overload('java.lang.String').implementation = function(cmd) {
                      if (cmd.indexOf("su") !== -1 || cmd.indexOf("which") !== -1) {
                          console.log("[Root] Blocked exec: " + cmd);
                          throw new Error("Permission denied");
                      }
                      return this.exec(cmd);
                  };
              } catch(e) {}
              
              // Hook PackageManager
              try {
                  var PM = Java.use("android.app.ApplicationPackageManager");
                  PM.getPackageInfo.overload('java.lang.String','int').implementation = function(pkg,f) {
                      for (var i = 0; i < RootPackages.length; i++) {
                          if (pkg === RootPackages[i]) {
                              console.log("[Root] Hidden package: " + pkg);
                              throw Java.use("android.content.pm.PackageManager$NameNotFoundException").$new(pkg);
                          }
                      }
                      return this.getPackageInfo(pkg, f);
                  };
              } catch(e) {}
              
              // Block System.exit
              try {
                  var System = Java.use("java.lang.System");
                  System.exit.implementation = function(code) {
                      console.log("[Root] Blocked exit(" + code + ")");
                  };
              } catch(e) {}
              
              // Block Process.killProcess
              try {
                  var Process = Java.use("android.os.Process");
                  Process.killProcess.implementation = function(pid) {
                      console.log("[Root] Blocked killProcess(" + pid + ")");
                  };
              } catch(e) {}
              
              console.log("[+] Root Detection Bypass Loaded!");
          });
          SCRIPT_EOF
          
          # ===== EMULATOR BYPASS SCRIPT =====
          cat > /tmp/scripts/emulator_bypass.js << 'SCRIPT_EOF'
          // Emulator Detection Bypass - Spoof to Samsung Galaxy
          Java.perform(function() {
              console.log("[*] Emulator Detection Bypass Loading...");
              
              try {
                  var Build = Java.use("android.os.Build");
                  Build.FINGERPRINT.value = "samsung/beyond1ltexx/beyond1:11/RP1A.200720.012/G973FXXU9FUL1:user/release-keys";
                  Build.MODEL.value = "SM-G973F";
                  Build.MANUFACTURER.value = "samsung";
                  Build.BRAND.value = "samsung";
                  Build.DEVICE.value = "beyond1";
                  Build.PRODUCT.value = "beyond1ltexx";
                  Build.HARDWARE.value = "exynos9820";
                  Build.BOARD.value = "exynos9820";
                  Build.TAGS.value = "release-keys";
                  Build.TYPE.value = "user";
                  Build.HOST.value = "21DJGL02";
                  Build.USER.value = "dpi";
                  console.log("[+] Build properties spoofed to Samsung Galaxy S10");
              } catch(e) {}
              
              try {
                  var BuildVersion = Java.use("android.os.Build$VERSION");
                  BuildVersion.SDK_INT.value = 30;
                  BuildVersion.RELEASE.value = "11";
              } catch(e) {}
              
              try {
                  var TM = Java.use("android.telephony.TelephonyManager");
                  TM.getDeviceId.overload().implementation = function() { return "358240051111110"; };
                  TM.getSubscriberId.implementation = function() { return "310260000000000"; };
                  TM.getLine1Number.implementation = function() { return "+15551234567"; };
                  TM.getNetworkOperatorName.implementation = function() { return "T-Mobile"; };
                  TM.getSimOperatorName.implementation = function() { return "T-Mobile"; };
              } catch(e) {}
              
              try {
                  var Debug = Java.use("android.os.Debug");
                  Debug.isDebuggerConnected.implementation = function() { return false; };
              } catch(e) {}
              
              try {
                  var Secure = Java.use("android.provider.Settings$Secure");
                  Secure.getString.implementation = function(resolver, name) {
                      if (name === "android_id") return "a1b2c3d4e5f6g7h8";
                      return this.getString(resolver, name);
                  };
              } catch(e) {}
              
              console.log("[+] Emulator Detection Bypass Loaded!");
          });
          SCRIPT_EOF
          
          # ===== SSL PINNING BYPASS =====
          cat > /tmp/scripts/ssl_bypass.js << 'SCRIPT_EOF'
          // Universal SSL Pinning Bypass
          Java.perform(function() {
              console.log("[*] SSL Pinning Bypass Loading...");
              
              try {
                  var TrustManager = Java.registerClass({
                      name: 'com.frida.TrustManager',
                      implements: [Java.use('javax.net.ssl.X509TrustManager')],
                      methods: {
                          checkClientTrusted: function(chain, authType) {},
                          checkServerTrusted: function(chain, authType) {},
                          getAcceptedIssuers: function() { return []; }
                      }
                  });
                  var SSLContext = Java.use('javax.net.ssl.SSLContext');
                  SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;','[Ljavax.net.ssl.TrustManager;','java.security.SecureRandom').implementation = function(km,tm,sr) {
                      console.log("[SSL] SSLContext.init bypassed");
                      this.init(km, [TrustManager.$new()], sr);
                  };
              } catch(e) {}
              
              try {
                  var CertificatePinner = Java.use('okhttp3.CertificatePinner');
                  CertificatePinner.check.overload('java.lang.String','java.util.List').implementation = function(h,p) {
                      console.log("[SSL] OkHttp3 CertificatePinner bypassed: " + h);
                  };
              } catch(e) {}
              
              try {
                  var WebViewClient = Java.use('android.webkit.WebViewClient');
                  WebViewClient.onReceivedSslError.implementation = function(view, handler, error) {
                      console.log("[SSL] WebView SSL error bypassed");
                      handler.proceed();
                  };
              } catch(e) {}
              
              console.log("[+] SSL Pinning Bypass Loaded!");
          });
          SCRIPT_EOF
          
          # ===== FRIDA DETECTION BYPASS =====
          cat > /tmp/scripts/frida_bypass.js << 'SCRIPT_EOF'
          // Frida Detection Bypass
          Java.perform(function() {
              console.log("[*] Frida Detection Bypass Loading...");
              
              try {
                  var fgets = Module.findExportByName("libc.so", "fgets");
                  Interceptor.attach(fgets, {
                      onLeave: function(retval) {
                          if (retval.isNull()) return;
                          var line = retval.readCString();
                          if (line && (line.indexOf("frida") !== -1 || line.indexOf("gum-js-loop") !== -1)) {
                              retval.writeUtf8String("");
                          }
                      }
                  });
              } catch(e) {}
              
              try {
                  var strstr = Module.findExportByName("libc.so", "strstr");
                  Interceptor.attach(strstr, {
                      onEnter: function(args) { this.needle = args[1].readCString(); },
                      onLeave: function(retval) {
                          if (this.needle && this.needle.indexOf("frida") !== -1) {
                              retval.replace(ptr(0));
                          }
                      }
                  });
              } catch(e) {}
              
              console.log("[+] Frida Detection Bypass Loaded!");
          });
          SCRIPT_EOF
          
          # ===== COMBINED DEXGUARD/BANKING BYPASS =====
          cat > /tmp/scripts/dexguard_bypass.js << 'SCRIPT_EOF'
          // DexGuard/Banking App RASP Bypass - All-in-One
          Java.perform(function() {
              console.log("[*] DexGuard/Banking RASP Bypass Loading...");
              
              // Root files to hide
              var RootFiles = ["/system/app/Superuser.apk","/sbin/su","/system/bin/su","/system/xbin/su","/data/local/su","/su/bin/su","/data/adb/magisk","/sbin/.magisk"];
              var RootPackages = ["com.topjohnwu.magisk","com.koushikdutta.superuser","eu.chainfire.supersu"];
              
              // File.exists hook
              try {
                  var File = Java.use("java.io.File");
                  File.exists.implementation = function() {
                      var path = this.getAbsolutePath();
                      for(var i=0;i<RootFiles.length;i++){if(path.indexOf(RootFiles[i])!==-1){return false;}}
                      return this.exists.call(this);
                  };
              } catch(e) {}
              
              // PackageManager hook
              try {
                  var PM = Java.use("android.app.ApplicationPackageManager");
                  PM.getPackageInfo.overload('java.lang.String','int').implementation = function(pkg,f) {
                      for(var i=0;i<RootPackages.length;i++){if(pkg===RootPackages[i]){throw Java.use("android.content.pm.PackageManager$NameNotFoundException").$new(pkg);}}
                      return this.getPackageInfo(pkg,f);
                  };
              } catch(e) {}
              
              // Build spoof
              try {
                  var Build = Java.use("android.os.Build");
                  Build.FINGERPRINT.value = "samsung/beyond1ltexx/beyond1:11/RP1A.200720.012/G973FXXU9FUL1:user/release-keys";
                  Build.MODEL.value = "SM-G973F";
                  Build.MANUFACTURER.value = "samsung";
                  Build.BRAND.value = "samsung";
                  Build.DEVICE.value = "beyond1";
                  Build.HARDWARE.value = "exynos9820";
                  Build.TAGS.value = "release-keys";
                  Build.TYPE.value = "user";
              } catch(e) {}
              
              // Block exits
              try {
                  var System = Java.use("java.lang.System");
                  System.exit.implementation = function(code) { console.log("[RASP] Blocked exit(" + code + ")"); };
              } catch(e) {}
              
              try {
                  var Process = Java.use("android.os.Process");
                  Process.killProcess.implementation = function(pid) { console.log("[RASP] Blocked kill(" + pid + ")"); };
              } catch(e) {}
              
              // Debug check bypass
              try {
                  var Debug = Java.use("android.os.Debug");
                  Debug.isDebuggerConnected.implementation = function() { return false; };
              } catch(e) {}
              
              // SSL bypass
              try {
                  var TrustManager = Java.registerClass({
                      name: 'com.bypass.TrustManager',
                      implements: [Java.use('javax.net.ssl.X509TrustManager')],
                      methods: {
                          checkClientTrusted: function(chain, authType) {},
                          checkServerTrusted: function(chain, authType) {},
                          getAcceptedIssuers: function() { return []; }
                      }
                  });
                  var SSLContext = Java.use('javax.net.ssl.SSLContext');
                  SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;','[Ljavax.net.ssl.TrustManager;','java.security.SecureRandom').implementation = function(km,tm,sr) {
                      this.init(km,[TrustManager.$new()],sr);
                  };
              } catch(e) {}
              
              try {
                  var CertificatePinner = Java.use('okhttp3.CertificatePinner');
                  CertificatePinner.check.overload('java.lang.String','java.util.List').implementation = function(h,p) {};
              } catch(e) {}
              
              console.log("[+] DexGuard/Banking RASP Bypass Loaded!");
          });
          SCRIPT_EOF
          
          echo "âœ… Frida bypass scripts created"
          ls -la /tmp/scripts/

      # ============================================
      # PHASE 8: CREATE API SERVER
      # ============================================

      - name: Create FastAPI Server
        run: |
          cat > /tmp/server.py << 'PYEOF'
          #!/usr/bin/env python3
          """
          Android Security Testing API v3.0 (Rooted Edition)
          - Root access via Magisk
          - Frida spawn mode for early hooking
          - Manual APK patching for AAB/split APKs
          - Comprehensive bypass scripts
          """
          
          import os, sys, json, time, shutil, hashlib, tempfile, subprocess, re
          from pathlib import Path
          from datetime import datetime
          from typing import Optional, Dict, Any, List
          from contextlib import asynccontextmanager
          
          from fastapi import FastAPI, HTTPException, UploadFile, File, Query
          from fastapi.responses import JSONResponse, FileResponse
          from fastapi.middleware.cors import CORSMiddleware
          from pydantic import BaseModel
          import uvicorn
          
          # Config
          WORK_DIR = "/tmp/apks"
          DECOMPILED_DIR = "/tmp/decompiled"
          PATCHED_DIR = "/tmp/patched"
          SCRIPTS_DIR = "/tmp/scripts"
          LOGS_DIR = "/tmp/logs"
          FRIDA_GADGET_X86_64 = "/tmp/frida-gadget-x86_64.so"
          FRIDA_GADGET_ARM64 = "/tmp/frida-gadget-arm64.so"
          
          for d in [WORK_DIR, DECOMPILED_DIR, PATCHED_DIR, SCRIPTS_DIR, LOGS_DIR]:
              os.makedirs(d, exist_ok=True)
          
          # Globals
          frida_device = None
          frida_session = None
          active_scripts = {}
          
          # Models
          class BashCommand(BaseModel):
              command: str
              timeout: int = 60
          
          class AdbCommand(BaseModel):
              command: str
              timeout: int = 60
          
          class FridaScript(BaseModel):
              script: str
              package_name: Optional[str] = None
              spawn: bool = False
          
          class PatchRequest(BaseModel):
              apk_path: str
              architecture: str = "x86_64"
              preserve_resources: bool = True
          
          class DownloadRequest(BaseModel):
              url: str
              filename: Optional[str] = None
          
          # Lifespan
          @asynccontextmanager
          async def lifespan(app: FastAPI):
              print("=== Android Security Server v3.0 Starting ===")
              yield
              print("=== Server Shutting Down ===")
          
          app = FastAPI(title="Android Security API v3.0", version="3.0.0", lifespan=lifespan)
          app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"])
          
          def run_cmd(cmd: str, timeout: int = 60) -> Dict[str, Any]:
              try:
                  r = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=timeout)
                  return {"success": r.returncode == 0, "returncode": r.returncode, "stdout": r.stdout, "stderr": r.stderr}
              except subprocess.TimeoutExpired:
                  return {"success": False, "error": "Timeout", "returncode": -1}
              except Exception as e:
                  return {"success": False, "error": str(e), "returncode": -1}
          
          def get_aapt() -> str:
              for p in [f"{os.environ.get('ANDROID_HOME','/usr/local/lib/android/sdk')}/build-tools/{v}/aapt2" for v in ["34.0.0","33.0.2","30.0.3"]]:
                  if os.path.exists(p): return p
              return "aapt2"
          
          def get_gadget(arch: str) -> Optional[str]:
              paths = {"x86_64": FRIDA_GADGET_X86_64, "arm64-v8a": FRIDA_GADGET_ARM64, "arm64": FRIDA_GADGET_ARM64}
              p = paths.get(arch)
              return p if p and os.path.exists(p) else None
          
          # ===== ENDPOINTS =====
          
          @app.get("/")
          async def root():
              return {"status": "ok", "service": "Android Security API v3.0", "docs": "/docs"}
          
          @app.get("/health")
          async def health():
              emu = run_cmd("adb devices | grep -E 'emulator|localhost'", 10)
              root = run_cmd("adb shell 'su -c id' 2>/dev/null || echo no", 10)
              frida = run_cmd("frida-ps -U 2>/dev/null | head -1", 10)
              return {
                  "status": "healthy",
                  "timestamp": datetime.now().isoformat(),
                  "emulator_connected": "emulator" in emu.get("stdout","") or "localhost" in emu.get("stdout",""),
                  "root_available": "uid=0" in root.get("stdout",""),
                  "frida_running": "PID" in frida.get("stdout","")
              }
          
          @app.get("/tools")
          async def tools():
              checks = {
                  "apktool": "apktool --version 2>&1 | head -1",
                  "jadx": "jadx --version 2>&1 | head -1",
                  "frida": "frida --version",
                  "objection": "objection version 2>&1 | grep -oP '\\d+\\.\\d+\\.\\d+' | head -1"
              }
              return {t: run_cmd(c, 10).get("stdout","").strip() or "N/A" for t,c in checks.items()}
          
          @app.post("/bash")
          async def bash(cmd: BashCommand):
              return run_cmd(cmd.command, cmd.timeout)
          
          @app.post("/adb")
          async def adb(cmd: AdbCommand):
              return run_cmd(f"adb {cmd.command}", cmd.timeout)
          
          @app.post("/adb/root")
          async def adb_root(cmd: AdbCommand):
              return run_cmd(f"adb shell 'su -c \"{cmd.command}\"'", cmd.timeout)
          
          @app.post("/upload")
          async def upload(file: UploadFile = File(...)):
              path = os.path.join(WORK_DIR, file.filename)
              content = await file.read()
              with open(path, "wb") as f: f.write(content)
              return {"success": True, "path": path, "size": len(content)}
          
          @app.post("/download")
          async def download(req: DownloadRequest):
              fn = req.filename or req.url.split("/")[-1].split("?")[0]
              path = os.path.join(WORK_DIR, fn)
              r = run_cmd(f'wget -q "{req.url}" -O "{path}"', 300)
              if os.path.exists(path):
                  return {"success": True, "path": path, "size": os.path.getsize(path)}
              return {"success": False, "error": r.get("stderr","")}
          
          @app.get("/files")
          async def files(directory: str = WORK_DIR):
              try:
                  return {"files": [{"name": f, "path": os.path.join(directory,f), "size": os.path.getsize(os.path.join(directory,f)) if os.path.isfile(os.path.join(directory,f)) else 0} for f in os.listdir(directory)]}
              except Exception as e:
                  raise HTTPException(500, str(e))
          
          @app.get("/apk/info")
          async def apk_info(apk_path: str):
              if not os.path.exists(apk_path): raise HTTPException(404, "APK not found")
              r = run_cmd(f'{get_aapt()} dump badging "{apk_path}" 2>/dev/null | head -30', 30)
              info = {"path": apk_path, "size_mb": round(os.path.getsize(apk_path)/(1024*1024), 2)}
              if r.get("success"):
                  out = r.get("stdout","")
                  for pat, key in [(r"package: name='([^']+)'","package"), (r"versionName='([^']+)'","version"), (r"sdkVersion:'(\d+)'","min_sdk")]:
                      m = re.search(pat, out)
                      if m: info[key] = m.group(1)
              with open(apk_path,"rb") as f: info["sha256"] = hashlib.sha256(f.read()).hexdigest()
              return {"success": True, "info": info}
          
          @app.post("/apk/patch")
          async def apk_patch(apk_path: str, arch: str = "x86_64"):
              if not os.path.exists(apk_path): raise HTTPException(404, "APK not found")
              r = run_cmd(f'objection patchapk --source "{apk_path}" --architecture {arch} 2>&1', 600)
              patched = apk_path.replace(".apk", ".objection.apk")
              if os.path.exists(patched):
                  return {"success": True, "patched_apk": patched, "size_mb": round(os.path.getsize(patched)/(1024*1024),2)}
              return {"success": False, "error": "Patching failed", "output": r.get("stdout",""), "stderr": r.get("stderr","")}
          
          @app.post("/apk/patch-manual")
          async def apk_patch_manual(req: PatchRequest):
              """Manual patching with resource preservation for AAB-generated APKs"""
              if not os.path.exists(req.apk_path): raise HTTPException(404, "APK not found")
              gadget = get_gadget(req.architecture)
              if not gadget: raise HTTPException(400, f"Gadget not available for {req.architecture}")
              
              work = tempfile.mkdtemp(prefix="patch_")
              base = os.path.basename(req.apk_path).replace(".apk","")
              output = os.path.join(PATCHED_DIR, f"{base}.patched.apk")
              
              try:
                  # Decode with -r (no resources) if preserving
                  flags = "-r -s" if req.preserve_resources else ""
                  r = run_cmd(f'apktool d {flags} "{req.apk_path}" -o "{work}/decoded" -f', 300)
                  if not r.get("success"):
                      r = run_cmd(f'apktool d "{req.apk_path}" -o "{work}/decoded" -f', 300)
                  
                  decoded = f"{work}/decoded"
                  
                  # Add gadget
                  lib_dir = f"{decoded}/lib/{req.architecture}"
                  os.makedirs(lib_dir, exist_ok=True)
                  shutil.copy(gadget, f"{lib_dir}/libfrida-gadget.so")
                  
                  # Modify manifest
                  manifest = f"{decoded}/AndroidManifest.xml"
                  if os.path.exists(manifest):
                      with open(manifest) as f: content = f.read()
                      if 'android.permission.INTERNET' not in content:
                          content = content.replace('<application', '<uses-permission android:name="android.permission.INTERNET"/>\n    <application')
                      if 'android:extractNativeLibs' in content:
                          content = re.sub(r'android:extractNativeLibs="[^"]*"', 'android:extractNativeLibs="true"', content)
                      else:
                          content = content.replace('<application', '<application android:extractNativeLibs="true"')
                      with open(manifest, 'w') as f: f.write(content)
                  
                  # Find and modify main activity smali
                  if os.path.exists(manifest):
                      with open(manifest) as f: mf = f.read()
                      main_match = re.search(r'android:name="([^"]+)"[^>]*>.*?android\.intent\.action\.MAIN', mf, re.DOTALL)
                      if main_match:
                          activity = main_match.group(1)
                          if activity.startswith("."):
                              pkg_match = re.search(r'package="([^"]+)"', mf)
                              if pkg_match: activity = pkg_match.group(1) + activity
                          smali_path = activity.replace(".", "/")
                          injection = '''
              const-string v0, "frida-gadget"
              invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
          '''
                          for sdir in ["smali", "smali_classes2", "smali_classes3"]:
                              sf = f"{decoded}/{sdir}/{smali_path}.smali"
                              if os.path.exists(sf):
                                  with open(sf) as f: sc = f.read()
                                  if ".method static constructor <clinit>()V" in sc:
                                      sc = sc.replace(".method static constructor <clinit>()V\n    .locals 1", f".method static constructor <clinit>()V\n    .locals 1\n{injection}")
                                  elif ".method public onCreate(Landroid/os/Bundle;)V" in sc:
                                      sc = re.sub(r'(\.method public onCreate\(Landroid/os/Bundle;\)V\s*\.locals \d+)', f"\\1\n{injection}", sc)
                                  with open(sf, 'w') as f: f.write(sc)
                                  break
                  
                  # Build
                  r = run_cmd(f'apktool b "{decoded}" -o "{work}/rebuilt.apk" --use-aapt2', 300)
                  if not r.get("success"):
                      r = run_cmd(f'apktool b "{decoded}" -o "{work}/rebuilt.apk"', 300)
                  
                  # Sign
                  if os.path.exists(f"{work}/rebuilt.apk"):
                      ks = "/tmp/debug.keystore"
                      if not os.path.exists(ks):
                          run_cmd(f'keytool -genkey -v -keystore {ks} -alias debug -keyalg RSA -keysize 2048 -validity 10000 -storepass android -keypass android -dname "CN=Debug"', 30)
                      run_cmd(f'apksigner sign --ks {ks} --ks-pass pass:android --out "{output}" "{work}/rebuilt.apk"', 60)
                      if os.path.exists(output):
                          return {"success": True, "patched_apk": output, "size_mb": round(os.path.getsize(output)/(1024*1024),2), "method": "manual"}
                  
                  return {"success": False, "error": "Build failed", "output": r.get("stdout","")}
              except Exception as e:
                  return {"success": False, "error": str(e)}
              finally:
                  shutil.rmtree(work, ignore_errors=True)
          
          @app.post("/apk/install")
          async def apk_install(apk_path: str):
              if not os.path.exists(apk_path): raise HTTPException(404, "APK not found")
              r = run_cmd(f'adb install -r "{apk_path}"', 180)
              return {"success": "Success" in r.get("stdout",""), **r}
          
          @app.post("/apk/launch")
          async def apk_launch(package_name: str):
              r = run_cmd(f'adb shell monkey -p "{package_name}" -c android.intent.category.LAUNCHER 1', 30)
              return {"success": r.get("returncode") == 0, **r}
          
          @app.post("/apk/decompile")
          async def apk_decompile(apk_path: str, tool: str = "jadx"):
              if not os.path.exists(apk_path): raise HTTPException(404, "APK not found")
              base = os.path.basename(apk_path).replace(".apk","")
              out = f"{DECOMPILED_DIR}/{base}"
              cmd = f'jadx -d "{out}" --deobf "{apk_path}"' if tool == "jadx" else f'apktool d "{apk_path}" -o "{out}" -f'
              r = run_cmd(cmd, 600)
              return {"success": os.path.exists(out), "output_dir": out, "tool": tool}
          
          # ===== FRIDA ENDPOINTS =====
          
          @app.get("/frida/processes")
          async def frida_processes():
              try:
                  import frida
                  d = frida.get_usb_device(timeout=10)
                  return {"success": True, "processes": [{"pid": p.pid, "name": p.name} for p in d.enumerate_processes()][:50]}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.get("/frida/apps")
          async def frida_apps():
              try:
                  import frida
                  d = frida.get_usb_device(timeout=10)
                  return {"success": True, "apps": [{"id": a.identifier, "name": a.name, "pid": a.pid} for a in d.enumerate_applications()]}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/frida/spawn")
          async def frida_spawn(package_name: str, script_path: Optional[str] = None):
              """Spawn app with Frida - hooks BEFORE app code runs (essential for RASP bypass)"""
              try:
                  import frida
                  d = frida.get_usb_device(timeout=10)
                  pid = d.spawn([package_name])
                  session = d.attach(pid)
                  loaded = False
                  if script_path and os.path.exists(script_path):
                      with open(script_path) as f: code = f.read()
                      s = session.create_script(code)
                      s.load()
                      loaded = True
                      active_scripts[script_path] = s
                  d.resume(pid)
                  return {"success": True, "pid": pid, "package": package_name, "script_loaded": loaded, "mode": "spawn"}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/frida/attach")
          async def frida_attach(package_name: str):
              try:
                  import frida
                  d = frida.get_usb_device(timeout=10)
                  session = d.attach(package_name)
                  return {"success": True, "package": package_name, "mode": "attach"}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.post("/frida/script")
          async def frida_script(req: FridaScript):
              try:
                  import frida
                  d = frida.get_usb_device(timeout=10)
                  if req.spawn and req.package_name:
                      pid = d.spawn([req.package_name])
                      session = d.attach(pid)
                      s = session.create_script(req.script)
                      s.load()
                      d.resume(pid)
                      return {"success": True, "mode": "spawn", "pid": pid}
                  if req.package_name:
                      session = d.attach(req.package_name)
                      s = session.create_script(req.script)
                      s.load()
                      return {"success": True, "mode": "attach"}
                  return {"success": False, "error": "No package_name provided"}
              except Exception as e:
                  return {"success": False, "error": str(e)}
          
          @app.get("/frida/scripts")
          async def frida_scripts():
              scripts = []
              if os.path.exists(SCRIPTS_DIR):
                  for f in os.listdir(SCRIPTS_DIR):
                      if f.endswith(".js"):
                          scripts.append({"name": f, "path": os.path.join(SCRIPTS_DIR, f)})
              return {"scripts": scripts}
          
          # ===== BYPASS ENDPOINTS =====
          
          @app.post("/frida/root-bypass")
          async def root_bypass(package_name: str, spawn: bool = True):
              with open(f"{SCRIPTS_DIR}/root_bypass.js") as f: code = f.read()
              return await frida_script(FridaScript(script=code, package_name=package_name, spawn=spawn))
          
          @app.post("/frida/emulator-bypass")
          async def emu_bypass(package_name: str, spawn: bool = True):
              with open(f"{SCRIPTS_DIR}/emulator_bypass.js") as f: code = f.read()
              return await frida_script(FridaScript(script=code, package_name=package_name, spawn=spawn))
          
          @app.post("/frida/ssl-bypass")
          async def ssl_bypass(package_name: str, spawn: bool = True):
              with open(f"{SCRIPTS_DIR}/ssl_bypass.js") as f: code = f.read()
              return await frida_script(FridaScript(script=code, package_name=package_name, spawn=spawn))
          
          @app.post("/frida/dexguard-bypass")
          async def dexguard_bypass(package_name: str, spawn: bool = True):
              with open(f"{SCRIPTS_DIR}/dexguard_bypass.js") as f: code = f.read()
              return await frida_script(FridaScript(script=code, package_name=package_name, spawn=spawn))
          
          @app.post("/frida/all-bypass")
          async def all_bypass(package_name: str, spawn: bool = True):
              """Load ALL bypass scripts"""
              combined = "// Combined Bypass\n"
              for f in ["root_bypass.js", "emulator_bypass.js", "ssl_bypass.js", "frida_bypass.js"]:
                  p = f"{SCRIPTS_DIR}/{f}"
                  if os.path.exists(p):
                      with open(p) as file: combined += f"\n// {f}\n" + file.read()
              return await frida_script(FridaScript(script=combined, package_name=package_name, spawn=spawn))
          
          if __name__ == "__main__":
              port = int(os.environ.get("SERVER_PORT", 8000))
              print(f"Starting server on port {port}")
              uvicorn.run(app, host="0.0.0.0", port=port)
          PYEOF
          
          chmod +x /tmp/server.py
          echo "âœ… Server created"

      # ============================================
      # PHASE 9: START SERVICES
      # ============================================

      - name: Start FastAPI Server
        run: |
          cd /tmp
          pip install fastapi uvicorn python-multipart --break-system-packages
          nohup python server.py > /tmp/logs/server.log 2>&1 &
          sleep 10
          curl -s http://localhost:${{ inputs.server_port }}/health || sleep 5
          curl -s http://localhost:${{ inputs.server_port }}/health
          echo "âœ… Server started"

      - name: Setup ngrok Tunnel
        run: |
          wget -q https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-linux-amd64.tgz
          tar -xzf ngrok-v3-stable-linux-amd64.tgz
          chmod +x ngrok
          ./ngrok http ${{ inputs.server_port }} --log=stdout > /tmp/logs/ngrok.log 2>&1 &
          sleep 10
          
          NGROK_URL=$(curl -s http://localhost:4040/api/tunnels | python3 -c "import sys,json; t=json.load(sys.stdin).get('tunnels',[]); print(t[0]['public_url'] if t else 'ERROR')" 2>/dev/null || echo "ERROR")
          
          if [ "$NGROK_URL" = "ERROR" ]; then
            sleep 5
            NGROK_URL=$(curl -s http://localhost:4040/api/tunnels | python3 -c "import sys,json; t=json.load(sys.stdin).get('tunnels',[]); print(t[0]['public_url'] if t else 'PENDING')")
          fi
          
          echo ""
          echo "=============================================="
          echo "ðŸš€ ANDROID SECURITY TESTING v3.0 READY"
          echo "=============================================="
          echo ""
          echo "ðŸ“¡ PUBLIC URL: $NGROK_URL"
          echo "ðŸ“š API DOCS:   $NGROK_URL/docs"
          echo ""
          echo "ðŸ”§ KEY ENDPOINTS:"
          echo "   GET  /health              - System status"
          echo "   GET  /tools               - Available tools"
          echo "   POST /upload              - Upload APK"
          echo "   POST /download            - Download from URL"
          echo "   GET  /apk/info            - APK information"
          echo "   POST /apk/patch           - Objection patch"
          echo "   POST /apk/patch-manual    - Manual patch (AAB fix)"
          echo "   POST /apk/install         - Install APK"
          echo "   POST /apk/launch          - Launch app"
          echo "   POST /apk/decompile       - Decompile APK"
          echo ""
          echo "ðŸ”“ FRIDA ENDPOINTS:"
          echo "   GET  /frida/processes     - List processes"
          echo "   GET  /frida/apps          - List apps"
          echo "   POST /frida/spawn         - Spawn with early hook"
          echo "   POST /frida/attach        - Attach to running"
          echo "   POST /frida/script        - Load custom script"
          echo ""
          echo "ðŸ›¡ï¸ BYPASS ENDPOINTS (use spawn=true):"
          echo "   POST /frida/root-bypass      - Root detection"
          echo "   POST /frida/emulator-bypass  - Emulator detection"
          echo "   POST /frida/ssl-bypass       - SSL pinning"
          echo "   POST /frida/dexguard-bypass  - DexGuard RASP"
          echo "   POST /frida/all-bypass       - All bypasses"
          echo ""
          echo "âš¡ ROOT STATUS: $ROOT_AVAILABLE"
          echo "â±ï¸ SESSION: ${{ inputs.session_duration }} minutes"
          echo "=============================================="

      - name: Keep Session Alive
        run: |
          DURATION=$(( ${{ inputs.session_duration }} * 60 ))
          ELAPSED=0
          while [ $ELAPSED -lt $DURATION ]; do
            STATUS=$(curl -s http://localhost:${{ inputs.server_port }}/health 2>/dev/null | python3 -c "import sys,json; print(json.load(sys.stdin).get('status','?'))" 2>/dev/null || echo "?")
            REMAIN=$(( (DURATION - ELAPSED) / 60 ))
            echo "[$(date '+%H:%M:%S')] Status: $STATUS | Remaining: ${REMAIN}m"
            sleep 60
            ELAPSED=$((ELAPSED + 60))
          done
          echo "Session completed"

      - name: Cleanup
        if: always()
        run: |
          pkill -f ngrok || true
          pkill -f "python server.py" || true
          adb emu kill 2>/dev/null || true
          echo "âœ… Cleanup complete"
